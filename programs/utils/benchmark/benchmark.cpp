#define WITH_GNUPLOT#include <iostream>#include <iomanip>#include <capd/capdlib.h>#include <capd/ddes/ddeslib.h>#include <capd/ddeshelper/ddeshelperlib.h>#include <capd/ddeshelper/DDEHelperRigorous.hpp>using namespace std;typedef capd::intervals::Interval<double, capd::rounding::DoubleRounding>  Interval;typedef capd::ddes::MackeyGlass<Interval, Interval> Eq;typedef capd::ddeshelper::RigorousHelper<Eq> Setup;void writeDetailedFile(std::string const& filepath, Setup::Vector const& x0, std::string header = ""){	std::ofstream out(filepath); out.precision(15);	if (header.length()){		if (header[0] != '#') out << "# ";		out << header;		if (header[header.length()-1] != '\n') out << "\n";	}	for (Setup::size_type i = 0; i < x0.dimension(); ++i){		out << i;		out << " " << capd::ddeshelper::to_dat(x0[i]);	}	out.close();}typedef std::pair<std::pair<double, double>, std::pair<double, double>> DiameterStats;DiameterStats getDiameterStats(Setup::Vector a){	DiameterStats result;	Setup::Vector r(a.dimension());	capd::vectalg::split(a, r);	result.first.first = r[0].rightBound(); // min	result.first.second = 0.; 				// max	result.second.first = 0.;				// avg	result.second.second = 0.;				// std	for (auto rit = r.begin(); rit != r.end(); ++rit){		double diam = rit->rightBound();		if (result.first.first > diam) result.first.first = diam;		if (result.first.second < diam) result.first.second = diam;		result.second.first += diam;	}	result.second.first /= r.dimension();	for (auto rit = r.begin(); rit != r.end(); ++rit){		double diam = rit->rightBound();		result.second.second += ((diam - result.second.first) * (diam - result.second.first));	}	result.second.second /= r.dimension();	result.second.second = sqrt(Setup::Real(result.second.second)).rightBound(); // to avoid error in math.sqrt after using Interval arithmetics	return result;}std::string statToText(DiameterStats const& stat, int mode, int precision){	double min = stat.first.first;		// min	double max = stat.first.second; 	// max	double avg = stat.second.first;		// avg	double std = stat.second.second;	// std	switch (mode){	case 0:		{ std::ostringstream oss; oss.precision(precision); oss << "$" << min << "$"; return oss.str(); }	case 1:		{ std::ostringstream oss; oss.precision(precision); oss << "$" << max << "$"; return oss.str(); }	case 2:		{ std::ostringstream oss; oss.precision(precision); oss << "$" << avg << " \\pm " << std << "$"; return oss.str(); }	}	return "";}class Tester {public:	typedef std::vector<std::string> HeaderList;	typedef std::vector<Setup::Vector> CompareItem;	typedef std::vector<std::pair<std::string, CompareItem>> CompareList;	Tester(std::string const& name, Setup& setup, Setup::Vector const& x0, Setup::Vector const& r0, Setup::Vector const& Xi):		m_name(name),		m_setup(setup),		m_x0(x0), m_r0(r0), m_Xi(Xi)	{		m_headers.push_back("Coeff. Order $k$");		m_headers.push_back("$h^k$");		m_headers.push_back("Diam. at $t=0$");		for (int k = 0; k <= setup.n() + 1; ++k){			CompareItem items;			std::ostringstream oss; oss << "$" << k << "$" << (k <= setup.n() ? " $\\star$" : " $\\dagger$");			m_cmplist.push_back(std::make_pair(oss.str(), items));		}		collectData(m_x0, m_r0, m_Xi);	}	Setup::Solution runDiameterTest(std::string const& header, int maxOrder, int steps, Setup::Real epsi){		m_headers.push_back(header);		m_setup.setMaximumOrder(maxOrder);		Setup::Vector Tx(m_setup.M());		Setup::Vector Tr0(m_setup.M());		Setup::Vector TXi(m_setup.p() * m_setup.DIMENSION);		// run computation		Setup::Solution T = m_setup.timemap(m_x0, m_r0, m_Xi, steps, epsi, Tx, Tr0, TXi);		// extract data to the compare list		collectData(Tx, Tr0, TXi);		return T;	}	void writeCompareTableLatex(				std::string const& dirpath,				std::string const& fileprefix,				int precision = 10,				std::string const& label = ""){		std::ofstream out(dirpath + "/" + fileprefix + ".tex"); out.precision(precision);		out << "\\documentclass[10pt]{report}\n";		out << "\\usepackage[a4paper, margin=0.5cm]{geometry}\n";		out << "\\usepackage{amsmath, amsthm, amssymb, amsfonts, graphicx}\n";		out << "\\begin{document}\n";		out << "\\begin{table}[h!]\n";		out << "\\begin{center}\n";		out << "\\begin{tabular}{";		for (auto h = m_headers.begin(); h != m_headers.end(); ++h)			out << "|c";		out << "|}\n";		out << "    \\hline\n";		out << "    " << (*m_headers.begin());		for (auto h = m_headers.begin() + 1; h != m_headers.end(); ++h)			out << " & " << (*h);		out << "\\\\ \n    \\hline\n";		Setup::Real hk = 1.0;		for (auto it = m_cmplist.begin(); it != m_cmplist.end(); ++it){			std::string rowName = it->first;			std::vector<DiameterStats> stats;			for (auto el = it->second.begin(); el != it->second.end(); ++el)				stats.push_back(getDiameterStats(*el));			std::string labels[3] = {" [min diam]   ", " [max diam]   ", " [avg + std] "};			int nprintStats = 1;			int printStats[] = {1};			for (int imode = 0; imode < nprintStats; ++imode){				out << "    " << rowName << labels[printStats[imode]] << " & " << hk.rightBound();				for (auto st = stats.begin(); st != stats.end(); ++st)					out << " & " << statToText(*st, printStats[imode], precision);				out << "\\\\ \n";			}			out << "    \\hline \n";			hk *= Setup::Real(m_setup.h());		}		auto mgparams = m_setup.params();		out << "\\end{tabular}\n";		out << "\\end{center}\n";		out << "\\caption{";		out << "Effectivenes of the method in computing rigorous enclosures of solutions in Mackey-Glass equation for parameters ";		out << "$n=" << mgparams[2] << "$, $\\tau = " << mgparams[3] << "$, $\\gamma=" << mgparams[0] << "$, $\\beta=" << mgparams[1] << "$. ";		out << "Table shows statistics of coefficients of a given order computed over all grid points of the solution at a given time.";		out << label;		out << " Note: superscript $\\star$ means that diameter of coefficients at a grid point was used (i.e. $j$ part of the f-set), ";		out << "where $\\dagger$ means enclosures over intervals of length $h$ were used ($\\Xi$ part used).";		out << "}\n";		out << "\\label{tab:" << fileprefix << "}\n";		out << "\\end{table}\n";		out << "\\end{document}\n";		out.close();		{			std::ostringstream cmd;			cmd << "cd '" << dirpath << "' && pdflatex '" << fileprefix << ".tex'";			system(cmd.str().c_str());		}	}private:	/** helper function to divide representation into orders */	void collectData(Setup::Vector const& x, Setup::Vector const& r0, Setup::Vector const& Xi){		for (int k = 0; k <= m_setup.n(); ++k){			Setup::Vector item(m_setup.p() + (k == 0 ? 1 : 0));			// TODO: mackey glass is scalar so it works for now. TODO: make it DIMENSION dependent			for (int i = 0; i < m_setup.p(); ++i)				item[i] = (x + r0)[k + 1 + i * (m_setup.n() + 1)];			if (k == 0)				item[item.dimension()-1] = (x + r0)[0];			m_cmplist[k].second.push_back(item);		}		m_cmplist[m_setup.n()+1].second.push_back(Xi);	}	HeaderList m_headers;	CompareList m_cmplist;	std::string m_name;	Setup& m_setup;	Setup::Vector m_x0;	Setup::Vector m_r0;	Setup::Vector m_Xi;};//////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char** argv){	cout.precision(15);	std::string extraMsg = "# generated with " + capd::ddeshelper::makeCommandLine(argc, argv);	std::string initialpath = "{[1.1,1.1]}";	std::string outprefix = "benchmark";	std::string outdirpath = ".";	int n = 4;	int p = 128;	int steps = -1;	Interval epsi= -1;	std::string epsiParam = "50%";	Interval diam(-1e-6,1e-6);	Interval diamXi(-1e-1,1e-1);	Interval N = 8.0;	int latexOutputPrecision = 8;	if (argc < 2) {		cout << "A benchmark program to compare expanding vs non-expanding implementation" << endl;		cout << " It uses a Mackey-Glass DDE as a benchmark: " << endl;		cout << "    $x'(t) = -*x(t) + 2*\\frac{x(t-\\tau)}{1+x(t-\\tau)^N}$." << endl << endl;		cout << "Usage:" << endl << endl;		cout << "    ./benchmark ";		cout << 		"initial=" << initialpath << " ";		cout << 		"dirpath=" << outdirpath << " ";		cout <<         "prefix=" << outprefix << " ";		cout << 		"diam='" << diam << "' ";		cout << 		"n=" << n << " ";		cout << 		"p=" << p << " ";		cout <<         "epsi='" << epsiParam << "' ";		cout <<         "xi='" << diamXi << "' ";		cout <<         "N='" << N << "' ";		cout << endl << endl;		cout << "At least one parameter must be specified, or this help will be shown." << endl;		cout << "Parameters are: " << endl;		cout << "  TODO: describe parameters" << endl;		cout << "  initial     path to file to load initial data x, r0 params, it contains path to coords also" << endl;		cout << "              the initial function will be given in those coordinates." << endl;		cout << "  dirpath     where to put output files"  << endl;		cout << "  prefix      prefix text in output files"  << endl;		cout << endl;		return 0;	}	for (int argi = 1; argi < argc; ++argi){		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "initial=", initialpath); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "dirpath=", outdirpath); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "prefix=", outprefix); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "diam=", diam); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "xi=", diamXi); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "n=", n); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "steps=", steps); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "p=", p); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "epsi=", epsiParam); }		{ capd::ddeshelper::conditionalExtractValue(argv[argi], "N=", N); }	}	Setup::ParamsVector defaultParams(Setup::PARAMS_COUNT);	defaultParams[0] = 1.0;// gamma	defaultParams[1] = 2.0;// beta	defaultParams[2] = N;  // n	defaultParams[3] = 2.0;// tau	int maxOrder = 3 * n;	if (steps < 0) steps = -steps * p;	if (steps < maxOrder * p) {		std::cout << "WARNING: " << steps << " steps to small for all tests with given order. Adjusted to " << maxOrder * p << endl;		steps = maxOrder * p;	}	capd::ddeshelper::mkdir_p(outdirpath);	Setup setup(p, n, defaultParams, steps, steps + 2, maxOrder);	if (epsiParam.back() == '%'){		std::istringstream iss(epsiParam.substr(0, epsiParam.length()-1));		double percent;		iss >> percent;		if (percent < 0.0 || percent >= 100.0) throw std::logic_error("Percent of the full step in epsi parameter must be in [0,100)");		percent /= 100.0;		epsi = Setup::Real(setup.h()) * percent;	}else{		std::istringstream iss(epsiParam);		iss >> epsi;		if (epsi < 0.0 || epsi >= Setup::Real(setup.h())) throw std::logic_error("The epsi parameter must be in [0,h)");	}	if (initialpath[0] == '{'){		// do nothing		cout << "Using constant initial data." << endl;	}else{		cout << "Load Setup from '" << initialpath << "'..." << flush;		cout << "DONE" << endl;	}	Setup::Vector x0(setup.M()), r0(setup.M()), Xi(setup.d() * setup.p());	Setup::Real reachTime = (Setup::Real(setup.h()) * steps);	for (int i = 0; i < setup.M(); ++i)		r0[i] = Interval(-1.0, 1.0) * diam;	for (int i = 0; i < setup.p() * setup.DIMENSION; ++i)		Xi[i] = Interval(-1.0, 1.0) * diamXi;	if (initialpath[0] == '{'){		Setup::Vector value(setup.DIMENSION);		std::istringstream iss(initialpath); iss >> value;		Setup::Solution c = setup.constantInitialSolution(value);		x0 = c.get_x();	}	// just for drawing...	Setup::Solution x = setup.dataToSolution(x0, r0, Xi); x *= 0.;	// run tests	Tester testerT("Timemap full steps", setup, x0, r0, Xi);	x = testerT.runDiameterTest("No expand", setup.n(), steps, 0.);	cout << "T 1" << endl;	setup.drawSolution(outdirpath, outprefix + "--T-no-expand", x);	testerT.runDiameterTest("Expand $n$", 2 * setup.n(), steps, 0.);	cout << "T 2a" << endl;	setup.drawSolution(outdirpath, outprefix + "--T-expand-n", x);	testerT.runDiameterTest("Expand $n + 1$", 2 * setup.n() + 1, steps, 0.);	cout << "T 2b" << endl;	setup.drawSolution(outdirpath, outprefix + "--T-expand-n1", x);	testerT.runDiameterTest("Expand $2n$", 3 * setup.n(), steps, 0.);	cout << "T 3" << endl;	setup.drawSolution(outdirpath, outprefix + "--T-expand-2n", x);	std::ostringstream infoT;	infoT << "Test setup was $\\varepsilon = " << epsi << "$ (full step $h = \\frac{\\tau}{p}$ = " << Setup::Real(setup.h()) << "), ";	infoT << "$T = " << reachTime.rightBound() << "$ ($" << steps << "$ full steps or $" << int(steps / setup.p()) << "$ full delays)" << endl;	testerT.writeCompareTableLatex(outdirpath, outprefix + "--T", latexOutputPrecision, infoT.str());	// run tests	Tester testerP("Timemap + epsilon", setup, x0, r0, Xi);	testerP.runDiameterTest("No expand", setup.n(), steps, epsi);	cout << "P 1" << endl;	setup.drawSolution(outdirpath, outprefix + "--P-no-expand", x);	testerP.runDiameterTest("Expand $n$", 2 * setup.n(), steps, epsi);	cout << "P 2a" << endl;	setup.drawSolution(outdirpath, outprefix + "--P-expand-n", x);	testerP.runDiameterTest("Expand $n + 1$", 2 * setup.n() + 1, steps, epsi);	cout << "P 2b" << endl;	setup.drawSolution(outdirpath, outprefix + "--P-expand-n1", x);	testerP.runDiameterTest("Expand $2n$", 3 * setup.n(), steps, epsi);	cout << "P 3" << endl;	setup.drawSolution(outdirpath, outprefix + "--P-expand-2n", x);	std::ostringstream infoP;	infoP << "Test setup was $\\varepsilon = " << epsi << "$ (full step $h = \\frac{\\tau}{p}$ = " << Setup::Real(setup.h()) << "), ";	infoP << "$T = " << reachTime.rightBound() << "$ ($" << steps << "$ full steps or $" << int(steps / setup.p()) << "$ full delays)" << endl;	testerP.writeCompareTableLatex(outdirpath, outprefix + "--P", latexOutputPrecision, infoP.str());//	setup.setMaximumOrder(maxOrder);//	Setup::Solution T = setup.timemap(x0, r0, Xi, steps, 0., Tx, Tr0, TXi);//	Setup::Solution P = setup.timemap(x0, r0, Xi, steps, epsi, Px, Pr0, PXi);////	HeaderList headers;//	CompareList cmplist;//	CompareItem xiItem;////	headers.push_back("Order");//	headers.push_back("T");//	headers.push_back("P");//	xiItem.push_back(TXi);//	xiItem.push_back(PXi);//	cmplist.push_back(std::make_pair(std::string("Xi"), xiItem));//	writeCompareTableLatex(outdirpath, outprefix, cmplist, headers);//	setup.drawSolution(outdirpath, outprefix + "--T", T);//	setup.drawSolution(outdirpath, outprefix + "--P", P);	return 0;}
///////////////////////////////////////////
///////////////////////////////////////////

