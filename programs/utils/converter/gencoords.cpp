#include <iostream>
#include <iomanip>
#include "common.h"

int main(int argc, char** argv){
	cout.precision(512);
	int precission = 512;
	int d = 1;
	int n = 1;
	std::string opt_help = "";
	if (argc >= 2){
		opt_help = argv[1];
	}
	if (argc < 6 || opt_help == "-h" || opt_help == "--h" || opt_help == "--help" || opt_help == "help" ){
		cout << "Program to generate coordinate frame from a selected set of vectors. " << endl;
		cout << "Program reads 2 sets (u_i's and w_i's of n d-dimensional vectors (n <= d)." << endl;
		cout << "Then creates a d x d matrix with u_i's as the first n columns" << endl;
		cout << "and the (d-n) columns being in a space complement to that given by w_i's" << endl;
		cout << "If you supply the same vectors u_i's as w_i's (same file), then the rest of" << endl;
		cout << "vectors will be simply perpendicular to the space generated by u_i's. " << endl;
		cout << "The common use for different w_i's is when doing hyperbolic periodic orbit coordinates, " << endl;
		cout << "and using the left-eigenvectors corresponding to the dominant right-eigenvectors." << endl;
		cout << "WARNING: It works only on DVectors (vectors with double entries). " << endl;
		cout << "NOTE: program will output useful conversion commands. " << endl;
		cout << "usage: gencoords [dimension] [n] [u_in_filepath] [w_in_filepath] [out_filepath] [precission(default: 512)]" << endl;
		return 0;
	}

	if (argc > 6){ std::istringstream issprec(argv[6]); issprec >> precission; }

	std::istringstream issdim(argv[1]); issdim >> d;
	std::istringstream issn(argv[2]); issn >> n;
	std::string in_u_filepath = argv[3];
	std::string in_w_filepath = argv[4];
	std::string out_filepath = argv[5];

	cout << "# reading u_i and w_i vectors " << flush;
	std::vector<MpVector> u(n), w(n);
	DVector iu(d), iw(d);
	ifstream uf(in_u_filepath);
	ifstream wf(in_w_filepath);
	for (int i = 0; i < n; ++i){
		uf >> iu; to_mpi_vector(iu, u[i], precission);
		wf >> iw; to_mpi_vector(iw, w[i], precission);
		cout << "." << flush;
	}
	wf.close();
	uf.close();
	cout << "DONE" << endl;

	auto dot_filter = [](MpFloat value){
		if (abs(value) < 1e-10)
			return "0";
		else if (abs(abs(value)-1.0) < 1e-11)
			return "1";
		else
			return "?";
	};
	// TODO: template lambda?
	auto dot_filter_float = [](float value){
		if (abs(value) < 1e-10)
			return "0";
		else if (abs(abs(value)-1.0) < 1e-11)
			return "1";
		else
			return "?";
	};
	// some tests
	cout << "# u_i . u_j test: " << endl << "# ";
	for (int i = 0; i < n; ++i){
		for (int j = 0; j < n; ++j){
			cout << dot_filter(u[i] * u[j]) << " ";
		}
		cout << endl << "# ";
	}
	cout << "# ====================" << endl;
	cout << "# u_i . w_j test: " << endl << "# ";
	for (int i = 0; i < n; ++i){
		for (int j = 0; j < n; ++j){
			cout << dot_filter(u[i] * w[j]) << " ";
		}
		cout << endl << "# ";
	}
	cout << "# ====================" << endl;
	cout << "# w_i . w_j test: " << endl << "# ";
	for (int i = 0; i < n; ++i){
		for (int j = 0; j < n; ++j){
			cout << dot_filter(w[i] * w[j]) << " ";
		}
		cout << endl << "# ";
	}
	cout << "# ====================" << endl;

	MpMatrix C(d, d);
	C.setToIdentity();

	for (int i = 0; i < n; ++i)
		C.column(i) = w[i];

	// TODO: make different algorithms

	cout << "# |0%==============100%|" << endl << "# |" << flush;
	// NOW only simplest one
	for (int i = 0; i < d; i++){
		if ((i+1) % (d / 20) == 0) cout << "*" << flush;
		for (int j = i + 1; j < d; ++j){
			MpVector qi = C.column(i);
			qi.normalize();
			MpVector qj = C.column(j);
			qj -= (qi * qj) * qi;
			qj.normalize();
			C.column(j) = qj;
		}
	}
	cout << "|" << endl;

	// put selected columns
	for (int i = 0; i < n; ++i)
		C.column(i) = u[i];

	MDMatrix outC(d, d);
	MIMatrix outIC(d, d);
	from_mpi_matrix(C, outC);
	outIC = outC;

	{
	cout << "# Output IMatrix START... " << flush;
	ofstream f(out_filepath + ".imatrix"); f.precision(16);
	f << outIC;
	f.close();
	cout << "DONE" << endl;
	}
	{
	cout << "# Output BINARY IMatrix START" << flush;
	capd::ddeshelper::saveBinary(out_filepath + ".imatrix.bin", outIC);
	cout << "DONE" << endl;
	}
	{
	cout << "# Output DMatrix START" << flush;
	ofstream f(out_filepath + ".matrix"); f.precision(16);
	f << outC;
	f.close();
	cout << "DONE" << endl;
	}

	std::vector<MDVector> ww(n, MDVector(d));
	for (int i = 0; i < n; ++i){
		from_mpi_vector(w[i], ww[i]);
	}
	cout << "# DMatrix tests: " << endl;
	cout << "# Those all should be 0's: " << endl << "# ";
	std::vector<double> bad_dots1, bad_dots2;
	for (int i = n+1; i < d; ++i){
		for (int j = 0; j < n; ++j){
			auto dot = outC.column(i) * ww[j];
			auto dotf = dot_filter_float(dot);
			if (dotf != "0")
				bad_dots1.push_back(dot);
			cout << dotf << " ";
		}
		cout << endl << "# ";
	}
	cout << "# bad_dots (" << bad_dots1.size() << "): "<< endl << "# ";
	for (auto& dot: bad_dots1) cout << dot << endl;
	cout << "# Those all should be 0's: " << endl << "# ";
	for (int i = n+1; i < d; ++i){
		for (int j = n+1+i; j < d; ++j){
			auto dot = outC.column(i) * outC.column(j);
			auto dotf = dot_filter_float(dot);
			if (dotf != "0")
				bad_dots2.push_back(dot);
			cout << dotf << " ";
		}
		cout << endl << "# ";
	}
	cout << "# bad_dots (" << bad_dots2.size() << "): "<< endl;
	for (auto& dot: bad_dots2) cout << dot << endl;
	cout << "# Those all should be 1's: " << endl << "# ";
	for (int i = n+1; i < d; ++i){
		cout << dot_filter_float(outC.column(i) * outC.column(i)) << " ";
	}
	cout << endl << "====================" << endl;
	cout << "# bad_dots1 (" << bad_dots1.size() << " out of " << (n * (d-n)) << ") "<< endl;
	cout << "# bad_dots2 (" << bad_dots2.size() << " out of " << ((d-n+1) * (d-n) / 2) << ") "<< endl;

	cout << "# program " << argv[0] << " DONE" << endl;

	cout << "# To compute inverse of the matrix, please run: (check the location of the conv.. programs!)" << endl;
	cout << "./convmatrix " << d << " bin " << out_filepath << ".imatrix.bin" << " inv bin " << out_filepath << "-inv.imatrix.bin" << endl;
	cout << "./invmatrixtest " << d << " bin " << out_filepath << ".imatrix.bin" << " " << out_filepath << "-inv.imatrix.bin" << endl;

	// TODO: write conversion commands
	return 0;}
