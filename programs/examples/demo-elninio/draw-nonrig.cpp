// comment out this to disable using system() command to plot things with gnuplot// do this especially if you do not have gnuplot installed.#define WITH_GNUPLOT// see this file for the initialization of the library for this particular example#include "setup-nonrig.h"using namespace std;//////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char** argv){	cout.precision(15);	// those variables are to store setup for the program run	// we fill them with default values defined in common.h	// user will be able to alter all of them through command line parameters	// alpha, beta, ... etc parameters are from the equation	Setup::Vector params(NUM_PARAMS);		// capd::ddeshelpers need to have parametrs as vector.	params[0] = DEFAULT_PAR_ALPHA;	params[1] = DEFAULT_PAR_BETA;	params[2] = DEFAULT_PAR_GAMMA;	params[3] = DEFAULT_PAR_KAPPA;	params[4] = DEFAULT_PAR_TAU1;	params[5] = DEFAULT_PAR_TAU1;	int init_steps = DEFAULT_STEPS;			// how many steps to do before start drawing, negative values will be converted to full delays!	int draw_steps = DEFAULT_STEPS;			// how many steps to do while drawing the solution, negative values will be converted to full delays!	std::string ivp_string = "{1.1}";		// we start with the constant initial function of the value given here. Alternatively, you can give a path to file with some solutions saved as CAPD vectors.	std::string outprefix = "draw-nonrig";	// prefix of the files generated by this program	std::string outdirpath = ".";			// the directory where to put programs, it might not exist if your compiler supports system() command, the program will generate it automatically and recursively.	std::string plot_type = "both";			// see the help for this parameter	int n = DEFAULT_N;						// n (i.e. order) of the (p,n)-representation of functions (see papers)	int p = DEFAULT_P;						// p (i.e. grid size) of the (p,n)-representation of functions (see papers)	// this is a helper class that can parse various parameters from command line	// this big wall os commands is just for human readable parameters to the program.	// you can type ./draw-nonrig -h to get a nice help later in your terminal.	capd::ddeshelper::ArgumentParser args(argc, argv);	args.parse("--p=", p, "Number of grid points, usually a power of two, like 32, 64, 128...");	args.parse("--n=", n, "Initial order of the method/representation (note that order of the method increases with each full delay), usually 4 is enough.");	args.parse("--tau=", params[4], "Basic delay");	args.parse("--alpha=", params[0], "DDE parameter");	args.parse("--beta=", params[1], "DDE parameter");	args.parse("--gamma=", params[2], "DDE parameter");	args.parse("--kappa=", params[3], "DDE parameter");	args.parse("--init-steps=", init_steps, "Number of full steps h=tau/p to be made before drawing. If negative, it will be the number of full delays.");	args.parse("--draw-steps=", draw_steps, "As above, but for the drawing part");	args.parse("--ivp=", ivp_string, "Definition of the initial function. Can point to a file with a vector compatible with (p,n), or a vector with a single value - it will start from const initial function of that value.");	args.parse("--plot=", plot_type, { std::string("solution"), std::string("phasespace"), std::string("none"), std::string("both") } );	args.parse("--prefix=", outprefix, "File prefix to all generated files");	args.parse("--dirpath=", outdirpath, "Directory path to output files. Program will try to sanitize this to prevent '/' or similar. ");	if (args.isHelpRequested()){		std::cout << args.getHelp() << endl;		return 0;	}	params[5] = params[4]; // TODO: this is just a hack for now, as Setup only handles one delay and it must be the last one, the extra delay is for later use for two-delays model. The system from the references has one or two delays.	std::string cmdline = args.getCommandLine();	if (cmdline == "./draw-nonrig")		std::cout << "# WARNING: no parameters set. Run command with -h or --help to see usage." << endl;	std::ostringstream run_info;	run_info << "# Generated with: \n#\n";	run_info << "#     " << cmdline << "\n#";	std::cout << "# Using (" << p << "," << n << ")-representation of the phasespace." << endl;	try{		// this is helper to handle various filenames		capd::ddeshelper::PathConfig paths(outdirpath, outprefix);		paths.mkdir_p(); // this makes the output folder to appear on the HDD		// convert negative values to full delays		if (init_steps < 0){ init_steps = -init_steps * p; }		if (draw_steps < 0){ draw_steps = -draw_steps * p; }		// configure the capdDDEs helper		Setup setup(params, p, n, -1, init_steps+draw_steps+1);		// configure the initial value for the pre-draw iteration		Setup::Vector initial(Setup::DIMENSION);		if (ivp_string[0] == '{'){			cout << "# Using const initial function x(s) = " << ivp_string << " for s \\in [-\\tau, 0]" << endl;			std::istringstream iss(ivp_string); iss >> initial;		} else {			auto sols = setup.loadData(ivp_string);			cout << "# Loading initial data from '" << ivp_string << "'" << endl;			initial = sols[0]; // there might be more items in sols, we always use 0 (TODO: add parameter to control this?)			if (sols.size() > 1) cout << "# WARNING: the file contains more than one initial data. Using the first one." << endl;			{ cout << "# Initial starts with: " << capd::ddeshelper::slice(initial, 60) << endl; }		}		// in x will be the initial value to start drawing from		// if there are any init_steps, then move initial that many steps and save the result in x		// Note: setup.M() is the M from (p,n)-representation as defined in the papers.		Setup::Vector x(setup.M());		cout << "# Initial integration for " << init_steps << " steps... " << flush;		if (init_steps) setup.integrate(init_steps, initial, x);		else x = initial;		cout << "# DONE" << endl;		// draw the solution for a given number of steps (step of size h = tau/p, as defined in the papers)		cout << "# Drawing for " << draw_steps << " steps... " << flush;		if (draw_steps){			// a helper function integrate() returns the solution segment x_t in the last argument			// and returns by value the Solution (the curve over the whole integration time).			Setup::Solution solution = setup.integrate(draw_steps, x, x);			// we extract solution segments from the whole curve now			Setup::Vector start = solution.subcurve(solution.pastTime(), setup.t(0)).get_x();			Setup::Vector iterated = solution.subcurve(solution.currentTime() - setup.t(p)).get_x();			// we save data for future use. You can use those files as initial='path/to/a/start-ivp.txt' argument to the program			setup.saveData(paths.filepath("start-ivp"), &start, &start + 1, run_info.str());			setup.saveData(paths.filepath("finish-ivp"), &iterated, &iterated + 1, run_info.str());			// we plot two type of plots - phasespace is the standard (x(t), x(t-tau)) plot used by many papers			// solution plot is just the solution over time (it can be done here, as we are dealing with scalar equation).			if (plot_type == "phasespace" || plot_type == "both")				setup.drawDelayMap(paths, solution);			if (plot_type == "solution" || plot_type == "both")				setup.drawSolution(paths, solution);		}		cout << "# DONE" << endl;		cout << "# Check files generated in '" << paths.dirpath() << "'" << endl;		cout << run_info.str() << endl;
		cout << "# PROGRAM END" << endl;	} catch (std::exception& e){		cout << "# ERROR: " << e.what() << endl;		cout << "# Please run program with -h or --help and check if your parameters are set right." << endl;	}	return 0;}
///////////////////////////////////////////
///////////////////////////////////////////

