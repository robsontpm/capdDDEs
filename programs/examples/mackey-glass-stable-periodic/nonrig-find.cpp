/* * TODO: Docs */// comment or uncomment the following for extra options// DDES_ALLOW_SYSTEM 		when uncommented, the program can produce some pictures from the proof,//							if you only interested in the proof of (2) then you can uncomment it// EXTRA_OUTPUT				uncommenting this will output more information to the standard output#define DDES_ALLOW_SYSTEM//#define EXTRA_OUTPUT// ====================== DO NOT MODIFY ANYTHING BELOW THIS LINE ===========================================#include "nonrig-setup.h"using namespace capd;
int main(int, char**){	// set common parameters for both codes	int p = 32;			// number of grid points in the basic interval. This will translate to the step size of the method := tau/p.	int max_order = 4;  // we are doing low order method (original ODE code was order = 20, but this is the test for possible chaos in DDE-perturbed ODE, so we should keep this low (see papers and 'Long Enough Integration time')
	interval a = interval(57) / interval(10);	// parameter a * 10
	interval b = interval(2) / interval(10);	// parameter b * 10	interval h = interval(1.0) / interval(p);	// the step size for both methods (CAPD ODES fixed step and capdDDEs grid size)	// setup the delayed equation.	// Eq does not have fancy setParameter() functions, but id does not need ones, as it is tailored	// for this specific Equation, not a general parser of equations as in CAPD.	// Therefore, it suffices to pass them in the constructor.	// The DDE-- classes declarations are in setup.h file, see how its done. You can use other names for those classes.
	Grid grid(h);	Eq eq(a, b);	DDEq dde(eq);	// setup DDE solver and Poincare map	DDESolver dde_solver(dde, max_order);	DDESection dde_section(3, 0);	DDEPoincare dde_pm(dde_solver, dde_section, poincare::CrossingDirection::MinusPlus);	// extra setup, only for DDEs	dde_pm.setRequiredSteps(0);	// ODE should not care about this, but we must disable this manually. This is important for true DDEs, but it is controlled by the DDE code itself to be safe.	dde_pm.setMaxSteps(1000);	// this is equivalent to ode_pm.setMaxReturnTime(), but less convenient probably	// setting up extra output - if needed	#ifdef EXTRA_OUTPUT	std::ostream& out = std::cout;	#else	std::ostringstream devnull;	std::ostream& out = devnull;	#endif	// Lambda functions that check some inequalities - they are the same as in original code	auto mappedLeft   = [] (IVector u) { return u[1] < g_leftM; };	auto mappedRight  = [] (IVector u) { return u[1] > g_rightN; };	auto mappedIn     = [] (IVector u) { return u[2] > g_bottom and u[2] < g_top and u[1] > g_left and u[1]<g_right; };	// here we will store results of the tests	bool resultDDE = true, resultODE = true;	// Here we check if [g_left,g_right]x[g_bottom,g_top] is mapped into itself by Poincare map.	// From these computations we also obtain that the sets N and M are mapped across the horizontal strip.	// This is one of the required conditions for the covering relations.	#ifdef CHECK_TRAPPING_REGION	int N = SLICE_N;	std::vector<IVector> x0_slices;	// here we will store data for nice plots	std::vector<IVector> Px_ODE, Px_DDE;	for (int i = 0; i < N; ++i){		ode_pm.setStep(h.rightBound()); // we are doing low order method, without this ODE code will struggle with the step control		ode_pm.turnOffStepControl();    // we are doing low order method, without this ODE code will struggle with the step control		auto ddePx = checkConditionDDE(out, grid, dde_pm, g_left, g_right, i, N, mappedIn, resultDDE, 1); // the difference here is that DDEs use Grid to define solutions.		auto odePx = checkConditionODE(out,       ode_pm, g_left, g_right, i, N, mappedIn, resultODE, 1); // ODEs code does not need grid, it can even have various time steps, see comment about step control above		// push data for draw later		x0_slices.push_back(odePx.first);		Px_ODE.push_back(odePx.second);		Px_DDE.push_back(ddePx.second);	}	cout << "DDE Existence of attractor: " << resultDDE << endl;	cout << "ODE Existence of attractor: " << resultODE << endl;	// output data needed for nice pictures	double box[] = {g_left, g_right, g_bottom, g_top};	plotTrappingRegion(box, "ddeplot", x0_slices, Px_DDE);	plotTrappingRegion(box, "odeplot", x0_slices, Px_ODE);	#endif // CHECK_TRAPPING_REGION	resultDDE = true; resultODE = true;	// Remaining inequalities for the covering relations N=>N, N=>M, M=>M, M=>N.	checkConditionDDE(out, grid,  dde_pm, g_leftM,  g_leftM,  0, 1, mappedLeft,  resultDDE);	checkConditionODE(out,        ode_pm, g_leftM,  g_leftM,  0, 1, mappedLeft,  resultODE);	cout << "DDE P^2( Left (M) ) < Left (M): " << resultDDE << endl;	cout << "ODE P^2( Left (M) ) < Left (M): " << resultODE << endl;	resultDDE = true; resultODE = true;	checkConditionDDE(out, grid,  dde_pm, g_rightM, g_rightM, 0, 1, mappedRight, resultDDE);	checkConditionODE(out,        ode_pm, g_rightM, g_rightM, 0, 1, mappedRight, resultODE);	cout << "DDE P^2( Right(M) ) > Right(N): " << resultDDE << endl;	cout << "ODE P^2( Right(M) ) > Right(N): " << resultODE << endl;	resultDDE = true; resultODE = true;	checkConditionDDE(out, grid,  dde_pm, g_leftN,  g_leftN,  0, 1, mappedRight, resultDDE);	checkConditionODE(out,        ode_pm, g_leftN,  g_leftN,  0, 1, mappedRight, resultODE);	cout << "DDE P^2( Left (N) ) > Right(N): " << resultDDE << endl;	cout << "ODE P^2( Left (N) ) > Right(N): " << resultODE << endl;	resultDDE = true; resultODE = true;	checkConditionDDE(out, grid,  dde_pm, g_rightN, g_rightN, 0, 1, mappedLeft,  resultDDE);	checkConditionODE(out,        ode_pm, g_rightN, g_rightN, 0, 1, mappedLeft,  resultODE);	cout << "DDE P^2( Right(N) ) < Left (M): " << resultDDE << endl;	cout << "DDE P^2( Right(N) ) < Left (M): " << resultODE << endl;	return 0;}
