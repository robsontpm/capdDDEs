/* * TODO: Docs */// comment or uncomment the following for extra options// DDES_ALLOW_SYSTEM 		when uncommented, the program can produce some pictures from the proof,//							if you only interested in the proof of (2) then you can uncomment it// EXTRA_OUTPUT				uncommenting this will output more information to the standard output#define DDES_ALLOW_SYSTEM//#define EXTRA_OUTPUT// ====================== DO NOT MODIFY ANYTHING BELOW THIS LINE ===========================================#include "nonrig-setup.h"DDEs::Vector find_candidate(DDEs& setup, DDEs::Vector v0);
int main(int, char**){	DDEs setup(PARAMS::params, PARAMS::p, PARAMS::n);	DDEs::Vector inital = find_candidate(setup, { PARAMS::v0 });	return 0;}DDEs::Vector find_candidate(DDEs& setup, DDEs::Vector v0){	const DDEs::Grid& grid = setup.grid();			// for easier access to grid	auto plot_dt = double(grid(1))/10.; 			// used in plots.	int steps = PARAMS::NUM_ITERATES * setup.p(); 	// how many full steps to do before starting refinement process, we convert parameter to full intervals!	auto zero = grid(0);		// t=0, as a time point on the grid	auto tau = grid(setup.p()); // tau as a time point on the grid	// make a constant x(s) = v0 solution segment on [-tau, 0] with an order n of jets set in the setup.	// We will use it to convert between Vector (no structure, just \R^M) and Solution (with structure, jets, grid, etc.)	// representation of various segments, when necessary.	DDEs::Solution candidate = setup.makeSegment(v0);	auto solution = setup.integrate(steps, candidate, candidate);	capd::ddeshelper::plot_value("plot-initial--", plot_dt, solution, false);	DDEs::Solution s(grid, -tau, zero, setup.n(), { 0.0 }); //you may use also setup.makeSegment();	s.value(zero) = { -1.0 };			// 0-th coefficient at t=0	s.value(-tau) = { +1.0 };			// 0-th coefficient at t=-tau	DDEs::JetSection section(s, 0.0); 	// this defines the section S = {x : x(0) == x(-tau)}.	solution = setup.poincare(section, candidate, candidate);	// we are re-using candidate as the output 3rd parameter, i.e. P(candidate)	DDEs::Solution segment = candidate;	capd::ddeshelper::plot_value("plot-candidate-on-section--", plot_dt, candidate, false);	for (int i = 0; i < PARAMS::NUM_POINCARE; ++i){		setup.poincare(section, candidate, candidate);	}	setup.poincare(section, candidate, candidate);	capd::vectalg::EuclLNorm<DDEs::Vector, DDEs::Matrix> euclNorm;	// for now, the arithmetic operations are not implemented in Solution, even for the same structures.	// so we just convert to vector to compute standard euclidean norm from CAPD.	cout << euclNorm((DDEs::Vector)segment - (DDEs::Vector)candidate) << endl;	capd::ddeshelper::plot_value("plot-candidate--", plot_dt, segment, false);	// TODO: do Newton.	return candidate;}
