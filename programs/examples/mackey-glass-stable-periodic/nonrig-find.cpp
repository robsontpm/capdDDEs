/* * TODO: Docs */// comment or uncomment the following for extra options// DDES_ALLOW_SYSTEM 		when uncommented, the program can produce some pictures from the proof,//							if you only interested in the proof of (2) then you can uncomment it// EXTRA_OUTPUT				uncommenting this will output more information to the standard output#define DDES_ALLOW_SYSTEM//#define EXTRA_OUTPUT// ====================== DO NOT MODIFY ANYTHING BELOW THIS LINE ===========================================#include "nonrig-setup.h"#include "rig-setup.h"DDEs::Vector find_candidate(DDEs& setup, DDEs::Vector v0);
int main(int, char**){	DDEs setup(PARAMS::params, PARAMS::p, PARAMS::n, PARAMS::REQUIRED_STEPS);	DDEs::Vector inital = find_candidate(setup, { PARAMS::v0 });	return 0;}DDEs::Vector find_candidate(DDEs& setup, DDEs::Vector v0){	const DDEs::Grid& grid = setup.grid();			// for easier access to grid	auto plot_dt = double(grid(1))/10.; 			// used in plots.	int steps = PARAMS::NUM_ITERATES * setup.p(); 	// how many full steps to do before starting refinement process, we convert parameter to full intervals!	auto zero = grid(0);		// t=0, as a time point on the grid	auto tau = grid(setup.p()); // tau as a time point on the grid	cout << "phase 0: start - refine by iteration" << endl;	// make a constant x(s) = v0 solution segment on [-tau, 0] with an order n of jets set in the setup.	// We will use it to convert between Vector (no structure, just \R^M) and Solution (with structure, jets, grid, etc.)	// representation of various segments, when necessary.	DDEs::Solution candidate = setup.makeSegment(v0);	auto trajectory = setup.integrate(steps, candidate, candidate);	// NOTE: with the helper functions such as integrate, poincare, make***(), etc.	//       you can use auto keyword in C++ 11 and newer to stop caring about the typenames!	capd::ddeshelper::plot_value("phase-0-initial--", plot_dt, trajectory, false);	DDEs::Solution s(grid, -tau, zero, setup.n(), { 0.0 }); //you may use also setup.makeSegment(); instead. This is just to show how to make segments by hand.	s.value(zero) = { -1.0 };			// 0-th coefficient at t=0	s.value(-tau) = { +1.0 };			// 0-th coefficient at t=-tau	DDEs::JetSection section(s, 0.0); 	// this defines the section S = {x : x(0) == x(-tau)}.	trajectory = setup.poincare(section, candidate, candidate);	// we are re-using candidate as the output 3rd parameter, i.e. P(candidate)	// we try to refine the periodic orbit by interation (we hope it is attracting)	capd::ddeshelper::plot_value("phase-0-candidate-on-section--", plot_dt, candidate, false);	for (int i = 0; i < PARAMS::NUM_POINCARE; ++i)		setup.poincare(section, candidate, candidate);	// now, we test how good the candidate is up to now.	// We are after stable solution, so iteration should produce quite good results.	DDEs::Solution segment = setup.makeSegment(); // make a const=0 function wth a proper structure.	trajectory = setup.poincare(section, candidate, segment);  // segment = P(candidate)	capd::vectalg::EuclLNorm<DDEs::Vector, DDEs::Matrix> euclNorm; // we use simple norm to assess the quality of the candidate	// for now, the arithmetic operations are not implemented in Solution, even for the same structures.	// so we just convert to vector to compute standard euclidean norm from CAPD.	cout << "Phase 0: candidate ||x - P(x)|| = " << euclNorm((DDEs::Vector)segment - (DDEs::Vector)candidate) << endl;	capd::ddeshelper::plot_value("phase-0-candidate--", plot_dt, candidate, false);	capd::ddeshelper::plot_value("phase-0-Pcandidate--", plot_dt, segment, false);	setup.drawSolution("phase-0-full-trajectory--", trajectory);	setup.drawDelayMap("phase-0-plot-phasespace--", trajectory);	cout << "phase 1: start - refine by Newton method" << endl;	auto M = setup.M(); //this is the dimension of the (p,n)-representation as described in FOCM papers.	DDEs::Matrix DP(M, M), V(M, M);	DDEs::Real diff = 1.0;	for (int z = 0; z < PARAMS::NUM_NEWTON; ++z){		diff = setup.refinePeriodic(cout, section, candidate, V, DP);		if (diff < PARAMS::EPS_NEWTON) break;	}	trajectory = setup.poincare(section, candidate, segment);  // segment = P(candidate)	cout << "Phase 1: candidate ||x - P(x)|| = " << euclNorm((DDEs::Vector)segment - (DDEs::Vector)candidate) << endl;	setup.drawSolution("phase-1-full-trajectory--", trajectory);	setup.drawDelayMap("phase-1-plot-phasespace--", trajectory);	cout << "Phase 2: start - finding good section and coordinates on it." << endl;	// the same as before but configured for C1 computations	DDEs::C1JetSection C1_section = setup.makeC1Section(DDEs::Vector(section), 0);	// we also convert candidate to be C1 compatible.	auto C1_candidate = setup.makeC1Segment(DDEs::Vector(candidate));	auto C1_segment = setup.makeC1Segment();	// we compute one last time the image on the simple section	// to get the C^1 data - the Jacobian DP of poincare map and the Monodromy matrix V	setup.poincare(C1_section, C1_candidate, C1_segment, V, DP);	cout << "Phase 2: candidate ||x - P(x)|| = " << euclNorm((DDEs::Vector)C1_segment - (DDEs::Vector)C1_candidate) << endl;	DDEs::Vector valRe(M), valIm(M); // eigenvalues are valRe[k] + i*valIm[k]	DDEs::Matrix vecRe(V), vecIm(V); // eigenvector for k-th eigenvalue is vecRe.column(k) + i * vecIm.column(k)	// we compute left eigenvectors, as the left eigenvector corresponding	// to eigenvalue 1 is a good candidate for section - see FOCM papers.	// this is done non-rigorously, as we only need a candidate	DDEs::Matrix VT(V); VT.Transpose();	capd::alglib::computeEigenvaluesAndEigenvectors(VT, valRe, valIm, vecRe, vecIm);	// check if the dominant eigenvalue seems to be corresponding to the section vector, as described in FOCM papers	if (valIm[0] != 0.) {		std::ostringstream info;		info << "Phase 2: Dominant eigenvalue has nonzero imaginary part: ";		info << valRe[0] << " " << valIm[0] << "*i. ";		info << "Continuing computations will likely end up bad.";		throw std::logic_error(info.str());	}	if ( abs(valRe[0] - 1.0) > 1e-2 ) {		std::ostringstream info;		info << "Phase 2: Dominant eigenvalue is real but quite far from 1";		info << valRe[0] << ".";		info << "Continuing computations will likely end up bad.";		throw std::logic_error(info.str());	}	cout << "Phase 2: dominant eigenvalue is real and sufficiently close to 1: " << valRe[0] << endl;	DDEs::Vector secvec = vecRe.column(0);	secvec.normalize();	DDEs::Real secval = secvec * (DDEs::Vector)candidate;	cout << "Phase 2: value of the section form on the candidate vector: " << secval << endl;	// we remember the second left eigenvector. If it has real eigenvalue, its orthogonal complement will	// be spanned by the rest of the eigenvectors, but we can compute better representation than by numerically unstable	// eigenvectors, simply by orthogonalization. This is more useful for unstable periodic orbits, where	// you should definitely use all eigenvectors with Re(eigenvalue) > 0. to build h-sets. For stable	// periodic orbits it will be just to get a good direction to subdivide sets.	DDEs::Vector second = vecRe.column(1);	second.normalize();	// here we prepare data for C^1 computations (i.e. producing approximation of the variational problem).	// It will be probably much easier in the future...	// what's important for this to wokr here is that segment and secvec are of dim M	// as described in (d, p, n)-representation of the functions. The DDEs setup (NonrigorousHelper)	// works on such functions best, and they are the best for doing computer assisted proofs later.	C1_candidate = setup.makeC1Segment(DDEs::Vector(candidate));	C1_segment = C1_candidate; C1_segment *= 0.;	C1_section = setup.makeC1Section(secvec, secval); // make a new, good section.	setup.poincare(C1_section, C1_candidate, C1_segment, DP);	cout << "Phase 2: candidate ||x - P(x)|| = " << euclNorm((DDEs::Vector)C1_segment - (DDEs::Vector)C1_candidate) << endl;	capd::alglib::computeEigenvaluesAndEigenvectors(DP, valRe, valIm, vecRe, vecIm);	DDEs::Matrix C(M, M); C.setToIdentity();	C.column(0) = secvec;	if (valIm[0] == 0.){		// we can use the dominant eigenvector easily, and we can use 'second' to get the representation		// of the space spanned by other eigenvectors.		// normally, you would like to include more right eigenvectors		// but we are after strongly attracting periodic orbits only in this example		C.column(1) = second;		capd::matrixAlgorithms::orthonormalize(C);		C.column(0) = secvec;		C.column(1) = vecRe.column(0);		C.column(1).normalize();	} else {		capd::matrixAlgorithms::orthonormalize(C);	}	cout << "Phase 3 start - preparing initial sets for the rigorous part." << endl;//	capd::ddeshelper::saveBinary("./x0.dvector.bin", );//	capd::ddeshelper::saveBinary();	cout << "Done. Please run the following command to compute rigotrous inverse of the coordinate matrix:" << endl;	// TODO:	return candidate;}
