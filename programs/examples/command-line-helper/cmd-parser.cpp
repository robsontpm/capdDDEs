#include <capd/capdlib.h>#include <capd/ddeshelper/DDESystemOSHelper.h>using namespace std;using capd::ddeshelper::ArgumentParser;//////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char** argv){	std::cout.precision(16);	// some variables we want to get the values. The given values will be the default ones.	int age = 99;	float height = 1.8;	std::string name = "John";	bool has_name = false;	capd::interval box { 0. };	capd::DVector v { 1., 2., 3.};	bool flag = false;	std::string choice = "<none>";	// make a new parser wth the command line arguments	ArgumentParser args(argc, argv);	// check if there is a config file given in the arguments (--config=path/to/a/file.txt)	// checking for the file should be the first thing, otherwise the previous	// parse commands would not have the access to this config.	args.checkConfigFile("config=");	// now, you can parse for different things.	args.parse("age=", age, "Your age");	args.parse("height=", height, "Your height (in meters)");	has_name = args.parse("name=", name, "Your name (if you want with surname, put the whole parameter in '..', e.g. 'name=John Doe'");	args.parse("box=", box, "Some interval");	args.parse("vector=", v, "Some DVector (must be 3D!)");	flag = args.parse("--flag", "Some flag (resent/absent)");	// this is how you can give the possible options.	// if user gives something else, the program will ignore it	// if no option with a valid option is given, then the parse will return false.	args.parse("choice=", choice, {std::string("A"), std::string("B")}, "Please make a choice from a given list!");	// it is important to check for help after all parse commands, as the nice	// list of parameters in generated with each of the parse() executions.	if (args.isHelpRequested()){		std::cout << args.getHelp() << endl << endl;		std::cout << "Help requested, exiting now. Review the arguments and rerun the program!" << endl;		return 0;	}	// this is how you can handle required parameters	// I decided I hardly use them, so there is no extra option to mark those as required in	// the help string, unfortunately.	if (!has_name){		std::cout << "ERROR! No name given! Name is a required parameter!" << endl;		std::cout << "       Please rerun program with name=YourName added, or" << endl;		std::cout << "       rerun program with --help option to see available parameters. " << endl;		return 0;	}	// the program starts here.	if (flag) {		cout << "|+----------------------------------------+" << endl;		cout << "||                                        |" << endl;		cout << "||                                        |" << endl;		cout << "||                                        |" << endl;		cout << "||                                        |" << endl;		cout << "||                                        |" << endl;		cout << "||########################################|" << endl;		cout << "||########################################|" << endl;		cout << "||########################################|" << endl;		cout << "||########################################|" << endl;		cout << "||########################################|" << endl;		cout << "|+----------------------------------------+" << endl;		for (int i = 0; i < 10; ++i) cout << "||" << endl;	}	std::cout << "Hello " << name << "!" << endl;	std::cout << name << " is " << age << " years old, and is " << int(height * 100.) << "cm tall." << endl;	std::cout << "Geometric data given: " << endl;	std::cout << "    box: " << box << endl;	std::cout << "    3dv: " << v << endl;	std::cout << "Choice: " << choice << endl;	std::cout << endl << endl << "Parsing log: " << args.getParsingLog() << endl;	// output the nice message with time, and the command.	// the default getStoryMessage() generates a string	// that has # in front of all lines, except 1st	// (so that you can produce some extra info in the first line, before the message.	std::cout << "# " << args.getStoryMessage() << endl;	return 0;}
///////////////////////////////////////////
///////////////////////////////////////////

