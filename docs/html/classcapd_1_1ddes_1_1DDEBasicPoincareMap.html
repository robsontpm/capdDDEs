<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAPDDDEs: capd::ddes::DDEBasicPoincareMap&lt; DynSysSpec, SectionSpec &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAPDDDEs
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
   <div id="projectbrief">ComputerAssistedProofsinDynamicsofDelayDifferentialEquations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>capd</b></li><li class="navelem"><b>ddes</b></li><li class="navelem"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">DDEBasicPoincareMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcapd_1_1ddes_1_1DDEBasicPoincareMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">capd::ddes::DDEBasicPoincareMap&lt; DynSysSpec, SectionSpec &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DDEBasicPoincareMap_8h_source.html">DDEBasicPoincareMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9bf2774e2540aa7bf6914191a4ca837c"><td class="memItemLeft" align="right" valign="top"><a id="a9bf2774e2540aa7bf6914191a4ca837c"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Class</b></td></tr>
<tr class="separator:a9bf2774e2540aa7bf6914191a4ca837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d6b816dfc0ffd4bab6ffd1992d066f"><td class="memItemLeft" align="right" valign="top"><a id="ac9d6b816dfc0ffd4bab6ffd1992d066f"></a>
typedef DynSysSpec&#160;</td><td class="memItemRight" valign="bottom"><b>DynSysType</b></td></tr>
<tr class="separator:ac9d6b816dfc0ffd4bab6ffd1992d066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2367151cc36f0a1ed10ffa9c415f2a40"><td class="memItemLeft" align="right" valign="top"><a id="a2367151cc36f0a1ed10ffa9c415f2a40"></a>
typedef SectionSpec&#160;</td><td class="memItemRight" valign="bottom"><b>SectionType</b></td></tr>
<tr class="separator:a2367151cc36f0a1ed10ffa9c415f2a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2cd2ff853340381a750143799822d4"><td class="memItemLeft" align="right" valign="top"><a id="a3c2cd2ff853340381a750143799822d4"></a>
typedef DynSysSpec::CurveType&#160;</td><td class="memItemRight" valign="bottom"><b>CurveType</b></td></tr>
<tr class="separator:a3c2cd2ff853340381a750143799822d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120a99e419f060c121057f1461478a30"><td class="memItemLeft" align="right" valign="top"><a id="a120a99e419f060c121057f1461478a30"></a>
typedef CurveType::TimePointType&#160;</td><td class="memItemRight" valign="bottom"><b>TimePointType</b></td></tr>
<tr class="separator:a120a99e419f060c121057f1461478a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fe84f23726919a2f7cc96e37b6ad45"><td class="memItemLeft" align="right" valign="top"><a id="ac7fe84f23726919a2f7cc96e37b6ad45"></a>
typedef CurveType::VectorType&#160;</td><td class="memItemRight" valign="bottom"><b>VectorType</b></td></tr>
<tr class="separator:ac7fe84f23726919a2f7cc96e37b6ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691ec1f094017e77e855a82b1e4d23d"><td class="memItemLeft" align="right" valign="top"><a id="a1691ec1f094017e77e855a82b1e4d23d"></a>
typedef CurveType::MatrixType&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:a1691ec1f094017e77e855a82b1e4d23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397b26c8d8b6e9a7841bc01900c66790"><td class="memItemLeft" align="right" valign="top"><a id="a397b26c8d8b6e9a7841bc01900c66790"></a>
typedef CurveType::ScalarType&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarType</b></td></tr>
<tr class="separator:a397b26c8d8b6e9a7841bc01900c66790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d5a46c2cf6c2aafc64a1155877a8fe"><td class="memItemLeft" align="right" valign="top"><a id="af9d5a46c2cf6c2aafc64a1155877a8fe"></a>
typedef CurveType::RealType&#160;</td><td class="memItemRight" valign="bottom"><b>RealType</b></td></tr>
<tr class="separator:af9d5a46c2cf6c2aafc64a1155877a8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3a1eb54b8b6b5ee5acc9519d07e66"><td class="memItemLeft" align="right" valign="top"><a id="a0ff3a1eb54b8b6b5ee5acc9519d07e66"></a>
typedef DynSysType::JacobianStorageType&#160;</td><td class="memItemRight" valign="bottom"><b>JacobianStorageType</b></td></tr>
<tr class="separator:a0ff3a1eb54b8b6b5ee5acc9519d07e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee25aef63055643ea5cd6e243256a626"><td class="memItemLeft" align="right" valign="top"><a id="aee25aef63055643ea5cd6e243256a626"></a>
typedef CurveType::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:aee25aef63055643ea5cd6e243256a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8ccd6bf8ea44806e7c1b865785d8efbf"><td class="memItemLeft" align="right" valign="top"><a id="a8ccd6bf8ea44806e7c1b865785d8efbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DDEBasicPoincareMap</b> (<a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">DDEBasicPoincareMap</a> const &amp;other)</td></tr>
<tr class="separator:a8ccd6bf8ea44806e7c1b865785d8efbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850ed85aeae39842e86969837f1f3177"><td class="memItemLeft" align="right" valign="top"><a id="a850ed85aeae39842e86969837f1f3177"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DDEBasicPoincareMap</b> (DynSysType &amp;dynsys, SectionType &amp;section, CrossingDirection direction=CrossingDirection::Both, int reqSteps=0, int maxSteps=-1, double binsearchEpsilon=DEFAULT_BINSEARCH_EPSILON)</td></tr>
<tr class="separator:a850ed85aeae39842e86969837f1f3177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea57b2b9505711ea5b59a77d12cd7a63"><td class="memItemLeft" align="right" valign="top">CurveType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#aea57b2b9505711ea5b59a77d12cd7a63">operator()</a> (CurveType const &amp;X)</td></tr>
<tr class="separator:aea57b2b9505711ea5b59a77d12cd7a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec9b7a9bf93e497b38ee9a6e20fc17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#aaeec9b7a9bf93e497b38ee9a6e20fc17">operator()</a> (CurveType &amp;curve, CurveType &amp;on_section, RealType &amp;out_approachTime)</td></tr>
<tr class="separator:aaeec9b7a9bf93e497b38ee9a6e20fc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3814773af94e5cb310f8971526a776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#a2d3814773af94e5cb310f8971526a776">operator()</a> (CurveType &amp;in_out_curve, CurveType &amp;in_out_Pcurve, RealType &amp;out_approachTime, VectorType &amp;out_x, VectorType &amp;out_Px, VectorType &amp;out_fPx, MatrixType &amp;out_V, MatrixType &amp;out_DP)</td></tr>
<tr class="separator:a2d3814773af94e5cb310f8971526a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfc0b41360017d417053f8c32719371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#a9cfc0b41360017d417053f8c32719371">setInitialV</a> (CurveType &amp;in_out_curve)</td></tr>
<tr class="separator:a9cfc0b41360017d417053f8c32719371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85df8673f19d569952a87bc7042f76c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#a85df8673f19d569952a87bc7042f76c5">setInitialV</a> (CurveType &amp;in_out_curve, MatrixType const &amp;V)</td></tr>
<tr class="separator:a85df8673f19d569952a87bc7042f76c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5975c76ac0bfacae3e26a8fd63ce2eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#a5975c76ac0bfacae3e26a8fd63ce2eed">setCurrentV</a> (CurveType &amp;in_out_curve, MatrixType const &amp;V)</td></tr>
<tr class="separator:a5975c76ac0bfacae3e26a8fd63ce2eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e41bb641b00c46dc391f4288068dc3"><td class="memItemLeft" align="right" valign="top"><a id="a07e41bb641b00c46dc391f4288068dc3"></a>
<a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">DDEBasicPoincareMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>setDirection</b> (CrossingDirection direction)</td></tr>
<tr class="separator:a07e41bb641b00c46dc391f4288068dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc765d07fa6baf7339025104f7fe12"><td class="memItemLeft" align="right" valign="top"><a id="a76dc765d07fa6baf7339025104f7fe12"></a>
CrossingDirection&#160;</td><td class="memItemRight" valign="bottom"><b>getDirection</b> ()</td></tr>
<tr class="separator:a76dc765d07fa6baf7339025104f7fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c07f8d12ec3d777c78f36121a5ed280"><td class="memItemLeft" align="right" valign="top"><a id="a5c07f8d12ec3d777c78f36121a5ed280"></a>
<a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">DDEBasicPoincareMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>setMaxSteps</b> (int maxSteps)</td></tr>
<tr class="separator:a5c07f8d12ec3d777c78f36121a5ed280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076854ede8009f0dd5643655c0ccd213"><td class="memItemLeft" align="right" valign="top"><a id="a076854ede8009f0dd5643655c0ccd213"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxSteps</b> ()</td></tr>
<tr class="separator:a076854ede8009f0dd5643655c0ccd213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f4fc75f6dbaa8719b67773f7fb55b3"><td class="memItemLeft" align="right" valign="top"><a id="ad5f4fc75f6dbaa8719b67773f7fb55b3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaximumSteps</b> ()</td></tr>
<tr class="separator:ad5f4fc75f6dbaa8719b67773f7fb55b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2676564685daa06e986aed873a2654c8"><td class="memItemLeft" align="right" valign="top"><a id="a2676564685daa06e986aed873a2654c8"></a>
<a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">DDEBasicPoincareMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>setRequiredSteps</b> (int requiredSteps)</td></tr>
<tr class="separator:a2676564685daa06e986aed873a2654c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db15b4d7aace0d8e3fabd995bbb9365"><td class="memItemLeft" align="right" valign="top"><a id="a9db15b4d7aace0d8e3fabd995bbb9365"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRequiredSteps</b> ()</td></tr>
<tr class="separator:a9db15b4d7aace0d8e3fabd995bbb9365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a51afde5264002e255705579bb48d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#a0a51afde5264002e255705579bb48d81">integrateUntilSectionCrossing</a> (CurveType &amp;curve, RealType &amp;timeBeforeSection, SingleStepFn stepFn)</td></tr>
<tr class="separator:a0a51afde5264002e255705579bb48d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253430a39173974c1e87dab5ae626672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#a253430a39173974c1e87dab5ae626672">findCrossingTime</a> (CurveType const &amp;curve, CurveType &amp;requested, RealType &amp;crossingTime, int testDirection)</td></tr>
<tr class="separator:a253430a39173974c1e87dab5ae626672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730e9cc74bbcf9f3cd7aee77e69c822c"><td class="memItemLeft" align="right" valign="top">CrossingDirection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html#a730e9cc74bbcf9f3cd7aee77e69c822c">detectCrossingDirection</a> (CurveType const &amp;curve)</td></tr>
<tr class="separator:a730e9cc74bbcf9f3cd7aee77e69c822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee64050e3bafa5c11a72ca3acb05342"><td class="memItemLeft" align="right" valign="top"><a id="a3ee64050e3bafa5c11a72ca3acb05342"></a>
RealType&#160;</td><td class="memItemRight" valign="bottom"><b>getLastEpsilonTime</b> () const</td></tr>
<tr class="separator:a3ee64050e3bafa5c11a72ca3acb05342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95572dc323729f807701a0d3f31f579"><td class="memItemLeft" align="right" valign="top"><a id="ac95572dc323729f807701a0d3f31f579"></a>
RealType&#160;</td><td class="memItemRight" valign="bottom"><b>getLastTimeBeforeSection</b> () const</td></tr>
<tr class="separator:ac95572dc323729f807701a0d3f31f579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb800b2452f58750f630218aef0bef9c"><td class="memItemLeft" align="right" valign="top"><a id="acb800b2452f58750f630218aef0bef9c"></a>
RealType&#160;</td><td class="memItemRight" valign="bottom"><b>getLastReachTime</b> () const</td></tr>
<tr class="separator:acb800b2452f58750f630218aef0bef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361857c7413d83910d41003801692454"><td class="memItemLeft" align="right" valign="top"><a id="a361857c7413d83910d41003801692454"></a>
JacobianStorageType&#160;</td><td class="memItemRight" valign="bottom"><b>getLastVariational</b> () const</td></tr>
<tr class="separator:a361857c7413d83910d41003801692454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef520b30779a1d3513ebba663d94739"><td class="memItemLeft" align="right" valign="top"><a id="a8ef520b30779a1d3513ebba663d94739"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLastStepsAfterSection</b> ()</td></tr>
<tr class="separator:a8ef520b30779a1d3513ebba663d94739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0e8ae40ffe8b134b204ca7c2506465"><td class="memItemLeft" align="right" valign="top"><a id="a6e0e8ae40ffe8b134b204ca7c2506465"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNormalizeVariational</b> () const</td></tr>
<tr class="separator:a6e0e8ae40ffe8b134b204ca7c2506465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd4ba8face8a0ead9ac0cee1fd5a368"><td class="memItemLeft" align="right" valign="top"><a id="adcd4ba8face8a0ead9ac0cee1fd5a368"></a>
<a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">Class</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>setNormalizeVariational</b> (bool value)</td></tr>
<tr class="separator:adcd4ba8face8a0ead9ac0cee1fd5a368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adf4ede9305db42ef318c5dd181283bc6"><td class="memItemLeft" align="right" valign="top"><a id="adf4ede9305db42ef318c5dd181283bc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkSteps</b> ()</td></tr>
<tr class="separator:adf4ede9305db42ef318c5dd181283bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96df8b62912d997a10cca7db26c00b2c"><td class="memItemLeft" align="right" valign="top"><a id="a96df8b62912d997a10cca7db26c00b2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractVariationalMatrix</b> (CurveType const &amp;curve, MatrixType &amp;fullV, MatrixType &amp;reducedV, std::vector&lt; size_type &gt; reducedShape, int p_howFar=-1) const</td></tr>
<tr class="separator:a96df8b62912d997a10cca7db26c00b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d38dfed36d2727964f5b2f99885e478"><td class="memItemLeft" align="right" valign="top"><a id="a0d38dfed36d2727964f5b2f99885e478"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extractVariationalMatrix</b> (CurveType const &amp;curve, MatrixType &amp;fullV) const</td></tr>
<tr class="separator:a0d38dfed36d2727964f5b2f99885e478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a62e2f5b504b76fad0688098a6a4c24d7"><td class="memItemLeft" align="right" valign="top"><a id="a62e2f5b504b76fad0688098a6a4c24d7"></a>
DynSysType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_dynsys</b></td></tr>
<tr class="separator:a62e2f5b504b76fad0688098a6a4c24d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1f69ece04ac628f60cc7153524036c"><td class="memItemLeft" align="right" valign="top"><a id="a7b1f69ece04ac628f60cc7153524036c"></a>
SectionType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_section</b></td></tr>
<tr class="separator:a7b1f69ece04ac628f60cc7153524036c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f251aba1639744a06d14caa8636adb1"><td class="memItemLeft" align="right" valign="top"><a id="a6f251aba1639744a06d14caa8636adb1"></a>
CrossingDirection&#160;</td><td class="memItemRight" valign="bottom"><b>m_direction</b></td></tr>
<tr class="separator:a6f251aba1639744a06d14caa8636adb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2225f9bfcf5018813f2e695ac6188253"><td class="memItemLeft" align="right" valign="top"><a id="a2225f9bfcf5018813f2e695ac6188253"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_requiredSteps</b></td></tr>
<tr class="separator:a2225f9bfcf5018813f2e695ac6188253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af060e5b37b27d0dd7ccbe40fd8e1741a"><td class="memItemLeft" align="right" valign="top"><a id="af060e5b37b27d0dd7ccbe40fd8e1741a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxSteps</b></td></tr>
<tr class="separator:af060e5b37b27d0dd7ccbe40fd8e1741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab726efd68d0e64894d3e3b3d2699c242"><td class="memItemLeft" align="right" valign="top"><a id="ab726efd68d0e64894d3e3b3d2699c242"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_steps</b></td></tr>
<tr class="separator:ab726efd68d0e64894d3e3b3d2699c242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa073ac7dc88b0f373b35c7f7b2c044c6"><td class="memItemLeft" align="right" valign="top"><a id="aa073ac7dc88b0f373b35c7f7b2c044c6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_binsearchEpsilon</b></td></tr>
<tr class="separator:aa073ac7dc88b0f373b35c7f7b2c044c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f60cff312113b49e780f3a044ce9a70"><td class="memItemLeft" align="right" valign="top"><a id="a8f60cff312113b49e780f3a044ce9a70"></a>
RealType&#160;</td><td class="memItemRight" valign="bottom"><b>m_lastTimeBeforeSection</b></td></tr>
<tr class="separator:a8f60cff312113b49e780f3a044ce9a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfcb58554e04c957171728ed46b4177"><td class="memItemLeft" align="right" valign="top"><a id="abdfcb58554e04c957171728ed46b4177"></a>
RealType&#160;</td><td class="memItemRight" valign="bottom"><b>m_lastEpsilonTime</b></td></tr>
<tr class="separator:abdfcb58554e04c957171728ed46b4177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af192bc5f72418f6ff1d9235c43f735dc"><td class="memItemLeft" align="right" valign="top"><a id="af192bc5f72418f6ff1d9235c43f735dc"></a>
JacobianStorageType&#160;</td><td class="memItemRight" valign="bottom"><b>m_variational</b></td></tr>
<tr class="separator:af192bc5f72418f6ff1d9235c43f735dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08faa5b417e6a69eb3a1ffeae778cd"><td class="memItemLeft" align="right" valign="top"><a id="aca08faa5b417e6a69eb3a1ffeae778cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_normalizeVariational</b></td></tr>
<tr class="separator:aca08faa5b417e6a69eb3a1ffeae778cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab24e3999af681048507194f007acc20"><td class="memItemLeft" align="right" valign="top"><a id="aab24e3999af681048507194f007acc20"></a>
std::vector&lt; size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_storedInitialShape</b></td></tr>
<tr class="separator:aab24e3999af681048507194f007acc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename DynSysSpec, typename SectionSpec&gt;<br />
class capd::ddes::DDEBasicPoincareMap&lt; DynSysSpec, SectionSpec &gt;</h3>

<p>Implementation of Poincare Map for use with nonrigorous DDESolvers.</p>
<p>In theory should work with any compatible DDEDynSys and Section.</p>
<p>TODO: (NOT URGENT): check the interface is compatible with CAPD Poincare Map TODO: (NOT URGENT): Especially operators and integrateUntilSectionCrossing, if they need extra n (numnber of iterates) parameter TODO: (FUTURE, NOT URGENT, RETHINK): should I rewrite the library so that normal PoncareMap from CAPD can be used with my system? It may not be feasible, as CAPD assumes not (semi) in dynamical system. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a730e9cc74bbcf9f3cd7aee77e69c822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730e9cc74bbcf9f3cd7aee77e69c822c">&#9670;&nbsp;</a></span>detectCrossingDirection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CrossingDirection <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::detectCrossingDirection </td>
          <td>(</td>
          <td class="paramtype">CurveType const &amp;&#160;</td>
          <td class="paramname"><em>curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>warning: might be time consuming, it (might) integrate the solution... it assumes curve is on section. </p>

</div>
</div>
<a id="a253430a39173974c1e87dab5ae626672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253430a39173974c1e87dab5ae626672">&#9670;&nbsp;</a></span>findCrossingTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::findCrossingTime </td>
          <td>(</td>
          <td class="paramtype">CurveType const &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>requested</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealType &amp;&#160;</td>
          <td class="paramname"><em>crossingTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>testDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>testDirection = -1 for before section testDirection = +1 for after section </p>
<p>binsearch for now</p>

</div>
</div>
<a id="a0a51afde5264002e255705579bb48d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a51afde5264002e255705579bb48d81">&#9670;&nbsp;</a></span>integrateUntilSectionCrossing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::integrateUntilSectionCrossing </td>
          <td>(</td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealType &amp;&#160;</td>
          <td class="paramname"><em>timeBeforeSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SingleStepFn&#160;</td>
          <td class="paramname"><em>stepFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>it extends the solution until the crossing with the section. Also, it takes into consideration the required number of steps (should be set-up before) It also moves away of section is initially curve crosses the section.</p>
<p>WARNING: it does not check for sanity of argument as of now, so it might cause runtime-errors if the proof is not well prepared. </p>

</div>
</div>
<a id="aaeec9b7a9bf93e497b38ee9a6e20fc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeec9b7a9bf93e497b38ee9a6e20fc17">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>on_section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealType &amp;&#160;</td>
          <td class="paramname"><em>out_approachTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First parameter will change! There will be a curve that reaches first full step after the section, define dover the whole integration time. So if you want to save it, use a copy in curve parameter.</p>
<p>In on_section there will be the image on the section, as close to section as possible.</p>
<p>The parameter on_section must be initialized with the desired "length" (time interval) and "order" of the representation. It also must be compatible (length, order) with the section.</p>
<p>Both parameters should be defined on the same Grid.</p>
<p>In out_approachTime you will get the return time to section. </p>

</div>
</div>
<a id="a2d3814773af94e5cb310f8971526a776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3814773af94e5cb310f8971526a776">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>in_out_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>in_out_Pcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealType &amp;&#160;</td>
          <td class="paramname"><em>out_approachTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>out_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>out_Px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>out_fPx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>out_V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>out_DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For other parameters and base description, see the other operator()</p>
<p>This is more complicated than the case of ODEs, but for technical reasons it is most desirable to work with vector/matrix representations of the objects when dealing with variational equation on the coefficients.</p>
<p>NOTE: CurveType must be defined with DataType that allows to handle extra Matrix data. I have special structures for this. CHeck examples and helper classes. Thanks to C++ lazy evaluation of templates this also works on the basic data structure as long as you do not call the function in the program.</p>
<p>out_x is vector representation of input curve out_Px is vector representation of the image on the section (Pcurve) out_fPx is the value of the "Vector Field" of the equation as defined in the Banach space in practice, if c = Px is a curve in C([-tau, 0], \R^d), then out_fPx = c'. This is theoretically correct when c is on the C^1 solutions manifold, i.e. c(0^-) == f(c) where f is the r.h.s. of the DDE. This is true for any initial curve, if the reachTime &gt; delay. See works for more explanation. out_V is the variational equation solution on the coefficients, i.e. d\varphi(t_p, x)/dx (in sense of the coefficients defining x) therefore it is of dimension out_x.dimension() x out_x.dimension() out_DP is the dP/dx (x) (derivative of P w.r.t. initial data, computed at point x) out_DP is obtained from out_V by some correction on the reach time t_p(x) in the neighbourhood of x. i.e. dP/dx (x) = d(\varphi(t_p(x), x))/dx = = \partial(\varphi)/\partial x (t_p(x), x) +</p><ul>
<li>\partial(\varphi)/\partial t (t_p(x), x) * d(t_p)/dx (x) = V + f(Px) * dt_p/dx (x) Please note that f(Px) is "vertical" and dt_p/dx (x) is "horizontal" vector so their product is a full matrix of desired dimension! We see that f(Px) is in out_fPx, V in out_V, then the last term is obtained by differentiation of the section condition equation:</li>
</ul>
<p>s(\varphi(t_p(x), x)) == 0</p>
<p>so we get (* means scalar product in \R^M where needed, M = out_x.dimension())</p>
<p>\gradient s * (V + f(Px) * dt_p/dx (x)) == 0 so dt_p/dx (x) = - ({\gradient s} * V) / ({\gradient s} * f(Px))</p>
<p>Note, that ({\gradient s} * f(Px)) is simply a scalar, and it needs to be not equal 0 for the formula to make sense. This is usual notion of the section to be transversal to the flow at x.</p>
<p>Finally, note that x, Px, fPx can be used in .set_x() to a curve of a proper structure (important!) to get interesting data. The proper structure is stored in Pcurve, i.e. usually, one can do: curve_x = Pcurve; curve_x.set_x(out_x); // guaranteed: curve_x == curve.subcurve([-tau, 0]) curve_Px = Pcurve; curve_Px.set_x(out_Px); // guaranteed: curve_Px == Pcurve curve_fPx = Pcurve; curve_fPx.set_x(out_fPx); // guaranteed: curve_fPx == (Pcurve)'</p>
<p>IMPORTANT: curve_fPx will be of one order higher than simply trying to compute Pcurve.dt()! IMPORTANT: as .dt() loses one order. So Pcurve.dt() is not a proper way to get "force field" IMPORTANT: on curve_Px, as the dimensions will be different (orders different). IMPORTANT: Therefore, use curve_fPx to get the value of the "force field" on curve_Px. </p>

</div>
</div>
<a id="aea57b2b9505711ea5b59a77d12cd7a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea57b2b9505711ea5b59a77d12cd7a63">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CurveType <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">CurveType const &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is probably the simplest version to be used by the end user.</p>
<p>It is simply applied like: </p><pre class="fragment">    CurveType X(...); // init to what you want
    auto PX = P(X);   // PX will be the same shape as X
    // so you can e.g. compute difference between representations
    capd::vectalg::EuclNorm&lt;VectorType, MatrixType&gt; euclNorm;
    auto diff = euclNorm((VectorType)PX - (VectorType)X)
</pre><p>to be compatible with standard notion and CAPD interface, It makes following assumptions:</p><ul>
<li>X and PX will have the same structure (i.e. over same grid points and jets of the same order).</li>
</ul>
<p>NOTE: you can retrieve information on reach time and epsilon step (see getLast***() functions), but you cannot acquire the solution on the whole time. If you need solution over the full integration time, then use other operator(). </p>

</div>
</div>
<a id="a5975c76ac0bfacae3e26a8fd63ce2eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5975c76ac0bfacae3e26a8fd63ce2eed">&#9670;&nbsp;</a></span>setCurrentV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::setCurrentV </td>
          <td>(</td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>in_out_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Experimental... </p>

</div>
</div>
<a id="a9cfc0b41360017d417053f8c32719371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfc0b41360017d417053f8c32719371">&#9670;&nbsp;</a></span>setInitialV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::setInitialV </td>
          <td>(</td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>in_out_curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>helper function, sets to Id the Variational matrix w.r.t. initial coefficients in curve TODO: DRY </p>

</div>
</div>
<a id="a85df8673f19d569952a87bc7042f76c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85df8673f19d569952a87bc7042f76c5">&#9670;&nbsp;</a></span>setInitialV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DynSysSpec , typename SectionSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; DynSysSpec, SectionSpec &gt;::setInitialV </td>
          <td>(</td>
          <td class="paramtype">CurveType &amp;&#160;</td>
          <td class="paramname"><em>in_out_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType const &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets initial V to a given Matrix. Matrix must be of a good shape TODO: DRY </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/robson/ROBERT-PRACA-CHMURA/eclipse-workspace/capdDDEs5.1.2/include/capd/ddes/<a class="el" href="DDEBasicPoincareMap_8h_source.html">DDEBasicPoincareMap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
