<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAPDDDEs: capd::ddeshelper::NonrigorousHelper&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAPDDDEs
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
   <div id="projectbrief">ComputerAssistedProofsinDynamicsofDelayDifferentialEquations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>capd</b></li><li class="navelem"><b>ddeshelper</b></li><li class="navelem"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">NonrigorousHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcapd_1_1ddeshelper_1_1NonrigorousHelper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">capd::ddeshelper::NonrigorousHelper&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DDEHelperNonrigorous_8h_source.html">DDEHelperNonrigorous.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a466f3a98813130bd731c24a5c1c287ad"><td class="memItemLeft" align="right" valign="top"><a id="a466f3a98813130bd731c24a5c1c287ad"></a>
typedef EqSpec&#160;</td><td class="memItemRight" valign="bottom"><b>Eq</b></td></tr>
<tr class="separator:a466f3a98813130bd731c24a5c1c287ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31830050e44c46b16bd6fe2019a48302"><td class="memItemLeft" align="right" valign="top"><a id="a31830050e44c46b16bd6fe2019a48302"></a>
typedef Eq::ParamType&#160;</td><td class="memItemRight" valign="bottom"><b>ParamType</b></td></tr>
<tr class="separator:a31830050e44c46b16bd6fe2019a48302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5f92ca0e40140b2e57f3e370579635"><td class="memItemLeft" align="right" valign="top"><a id="a2b5f92ca0e40140b2e57f3e370579635"></a>
typedef VectorSpec&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b></td></tr>
<tr class="separator:a2b5f92ca0e40140b2e57f3e370579635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfaa8196045baf1843c0642c01b5653"><td class="memItemLeft" align="right" valign="top"><a id="afdfaa8196045baf1843c0642c01b5653"></a>
typedef MatrixSpec&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b></td></tr>
<tr class="separator:afdfaa8196045baf1843c0642c01b5653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe3c52f5904e189f94c9f7261ffab55"><td class="memItemLeft" align="right" valign="top"><a id="abbe3c52f5904e189f94c9f7261ffab55"></a>
typedef Matrix::ScalarType&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b></td></tr>
<tr class="separator:abbe3c52f5904e189f94c9f7261ffab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315a7ce166876515884745619e3dd1be"><td class="memItemLeft" align="right" valign="top"><a id="a315a7ce166876515884745619e3dd1be"></a>
typedef Matrix::ScalarType&#160;</td><td class="memItemRight" valign="bottom"><b>Real</b></td></tr>
<tr class="separator:a315a7ce166876515884745619e3dd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0283c381a30106817e870230a179b6"><td class="memItemLeft" align="right" valign="top"><a id="a8c0283c381a30106817e870230a179b6"></a>
typedef Eq::ParamsVectorType&#160;</td><td class="memItemRight" valign="bottom"><b>ParamsVector</b></td></tr>
<tr class="separator:a8c0283c381a30106817e870230a179b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2fbe627bbf70f46ecfa47379135230"><td class="memItemLeft" align="right" valign="top"><a id="a6f2fbe627bbf70f46ecfa47379135230"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DiscreteTimeGrid.html">capd::ddes::DiscreteTimeGrid</a>&lt; Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Grid</b></td></tr>
<tr class="separator:a6f2fbe627bbf70f46ecfa47379135230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f43a77f520be5449233d28cd695392e"><td class="memItemLeft" align="right" valign="top"><a id="a5f43a77f520be5449233d28cd695392e"></a>
typedef Grid::TimePointType&#160;</td><td class="memItemRight" valign="bottom"><b>TimePoint</b></td></tr>
<tr class="separator:a5f43a77f520be5449233d28cd695392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf92e42037ccbe3401395a9d0efd1e6b"><td class="memItemLeft" align="right" valign="top"><a id="abf92e42037ccbe3401395a9d0efd1e6b"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1GenericJet.html">capd::ddes::GenericJet</a>&lt; TimePoint, Vector, Vector, Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Jet</b></td></tr>
<tr class="separator:abf92e42037ccbe3401395a9d0efd1e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00f18e37801af152858340fca4244be"><td class="memItemLeft" align="right" valign="top"><a id="ac00f18e37801af152858340fca4244be"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1GenericJet.html">capd::ddes::GenericJet</a>&lt; TimePoint, <a class="el" href="classcapd_1_1ddes_1_1VectorWithJacData.html">capd::ddes::VectorWithJacData</a>&lt; Vector, Matrix &gt;, Vector, Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>C1Jet</b></td></tr>
<tr class="separator:ac00f18e37801af152858340fca4244be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35870445c1dda17475f44e094507cad"><td class="memItemLeft" align="right" valign="top"><a id="ad35870445c1dda17475f44e094507cad"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">capd::ddes::DDEPiecewisePolynomialCurve</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1DiscreteTimeGrid.html">Grid</a>, <a class="el" href="classcapd_1_1ddes_1_1GenericJet.html">Jet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Solution</b></td></tr>
<tr class="separator:ad35870445c1dda17475f44e094507cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fc140ecc9c1e36a89afdd12206ed60"><td class="memItemLeft" align="right" valign="top"><a id="a79fc140ecc9c1e36a89afdd12206ed60"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">capd::ddes::DDEPiecewisePolynomialCurve</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1DiscreteTimeGrid.html">Grid</a>, <a class="el" href="classcapd_1_1ddes_1_1GenericJet.html">C1Jet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>C1Solution</b></td></tr>
<tr class="separator:a79fc140ecc9c1e36a89afdd12206ed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e002f6effee0a28fdebc4632974ee6"><td class="memItemLeft" align="right" valign="top"><a id="ae3e002f6effee0a28fdebc4632974ee6"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1GenericJet.html">Jet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CurvePiece</b></td></tr>
<tr class="separator:ae3e002f6effee0a28fdebc4632974ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9090ab2048eb4f2362d7253e9eedf3"><td class="memItemLeft" align="right" valign="top"><a id="a5a9090ab2048eb4f2362d7253e9eedf3"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">capd::ddes::BasicDiscreteDelaysFunctionalMap</a>&lt; Eq, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>C1DDEq</b></td></tr>
<tr class="separator:a5a9090ab2048eb4f2362d7253e9eedf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acfd53671f88208ef551943cfb2cdd1"><td class="memItemLeft" align="right" valign="top"><a id="a7acfd53671f88208ef551943cfb2cdd1"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">capd::ddes::BasicDiscreteDelaysFunctionalMap</a>&lt; Eq, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DDEq</b></td></tr>
<tr class="separator:a7acfd53671f88208ef551943cfb2cdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7986f68aaa992f8a10dbae5def1e9b5"><td class="memItemLeft" align="right" valign="top"><a id="ab7986f68aaa992f8a10dbae5def1e9b5"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">capd::ddes::DDENonrigorousTaylorSolver</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">C1DDEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>C1Solver</b></td></tr>
<tr class="separator:ab7986f68aaa992f8a10dbae5def1e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409993105001a18077b5739a0750a303"><td class="memItemLeft" align="right" valign="top"><a id="a409993105001a18077b5739a0750a303"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">capd::ddes::DDENonrigorousTaylorSolver</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">DDEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Solver</b></td></tr>
<tr class="separator:a409993105001a18077b5739a0750a303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31107dc17933e66dca29a3485c62f6a"><td class="memItemLeft" align="right" valign="top"><a id="ab31107dc17933e66dca29a3485c62f6a"></a>
typedef C1Solver::VariableStorageType&#160;</td><td class="memItemRight" valign="bottom"><b>Variables</b></td></tr>
<tr class="separator:ab31107dc17933e66dca29a3485c62f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8088ad103f261ab2a0757e35a9ab0e1d"><td class="memItemLeft" align="right" valign="top"><a id="a8088ad103f261ab2a0757e35a9ab0e1d"></a>
typedef C1Solver::JacobianStorageType&#160;</td><td class="memItemRight" valign="bottom"><b>Jacobians</b></td></tr>
<tr class="separator:a8088ad103f261ab2a0757e35a9ab0e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2767e10189712b8db7f20735554d0d9e"><td class="memItemLeft" align="right" valign="top"><a id="a2767e10189712b8db7f20735554d0d9e"></a>
typedef C1Solver::ValueStorageType&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b></td></tr>
<tr class="separator:a2767e10189712b8db7f20735554d0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358dc9dbd46406fecfc06cf21c5a6302"><td class="memItemLeft" align="right" valign="top"><a id="a358dc9dbd46406fecfc06cf21c5a6302"></a>
typedef C1Solver::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a358dc9dbd46406fecfc06cf21c5a6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7e479f2e4ee2d2cbf789a4e9dec6ba"><td class="memItemLeft" align="right" valign="top"><a id="abc7e479f2e4ee2d2cbf789a4e9dec6ba"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>step_type</b></td></tr>
<tr class="separator:abc7e479f2e4ee2d2cbf789a4e9dec6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e2090f24cb3aa379f0b0a8c123cc2e"><td class="memItemLeft" align="right" valign="top"><a id="a21e2090f24cb3aa379f0b0a8c123cc2e"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">capd::ddes::DDEJetSection</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>C1JetSection</b></td></tr>
<tr class="separator:a21e2090f24cb3aa379f0b0a8c123cc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2f38aa2eeeca3c113bcc717606df9a"><td class="memItemLeft" align="right" valign="top"><a id="a8b2f38aa2eeeca3c113bcc717606df9a"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1GenericJet.html">C1JetSection::JetType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C1SecJet</b></td></tr>
<tr class="separator:a8b2f38aa2eeeca3c113bcc717606df9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fed5a1c70bc157614a911bc0e824564"><td class="memItemLeft" align="right" valign="top"><a id="a9fed5a1c70bc157614a911bc0e824564"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">C1Solver</a>, <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>C1PoincareMap</b></td></tr>
<tr class="separator:a9fed5a1c70bc157614a911bc0e824564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2bd24caf470f2d0c550230b3dea501"><td class="memItemLeft" align="right" valign="top"><a id="a7e2bd24caf470f2d0c550230b3dea501"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">capd::ddes::DDEJetSection</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>JetSection</b></td></tr>
<tr class="separator:a7e2bd24caf470f2d0c550230b3dea501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a246bb43caf2a88c10117fb31a1f88"><td class="memItemLeft" align="right" valign="top"><a id="a56a246bb43caf2a88c10117fb31a1f88"></a>
typedef <a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">capd::ddes::DDEBasicPoincareMap</a>&lt; <a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">Solver</a>, <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PoincareMap</b></td></tr>
<tr class="separator:a56a246bb43caf2a88c10117fb31a1f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b90f1eab57cc7b0da9964f567097956"><td class="memItemLeft" align="right" valign="top"><a id="a5b90f1eab57cc7b0da9964f567097956"></a>
typedef <a class="el" href="classcapd_1_1ddeshelper_1_1CoordinateFrame.html">capd::ddeshelper::CoordinateFrame</a>&lt; Matrix, Vector, Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CoordinateFrame</b></td></tr>
<tr class="separator:a5b90f1eab57cc7b0da9964f567097956"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99d6006c4e704bb1c1f84b2fb17c4146"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a99d6006c4e704bb1c1f84b2fb17c4146">NonrigorousHelper</a> (ParamsVector <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ac7e612e1bfa79f6976d12bede1a3dd7a">params</a>, size_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#abb23f680d57b754324d7bd06b5d78635">p</a>, size_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n</a>, step_type reqSteps=0, step_type maxSteps=0, size_type maxOrder=10)</td></tr>
<tr class="separator:a99d6006c4e704bb1c1f84b2fb17c4146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e62e94b910ad0bd7af27293959c938"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ac1e62e94b910ad0bd7af27293959c938">NonrigorousHelper</a> (std::string filepath, step_type reqSteps=0, step_type maxSteps=0, size_type maxOrder=10)</td></tr>
<tr class="separator:ac1e62e94b910ad0bd7af27293959c938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6d44d77612316f0384db78f7c3eff2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a0a6d44d77612316f0384db78f7c3eff2">NonrigorousHelper</a> (std::istream &amp;input, step_type reqSteps=0, step_type maxSteps=0, size_type maxOrder=10)</td></tr>
<tr class="separator:a0a6d44d77612316f0384db78f7c3eff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f364979bd5cc242a0e65aa87ee32b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a0f364979bd5cc242a0e65aa87ee32b75">setRequiredSteps</a> (step_type reqSteps, bool control_steps=true)</td></tr>
<tr class="separator:a0f364979bd5cc242a0e65aa87ee32b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c70a51464c0cfe5b69944e68b1281aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a7c70a51464c0cfe5b69944e68b1281aa">setMaximumSteps</a> (step_type maxSteps, bool control_steps=true)</td></tr>
<tr class="separator:a7c70a51464c0cfe5b69944e68b1281aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affebb75e5ec3a8b29d06a39b9299521f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#affebb75e5ec3a8b29d06a39b9299521f">setMaximumOrder</a> (step_type maxOrder, bool control_steps=true)</td></tr>
<tr class="separator:affebb75e5ec3a8b29d06a39b9299521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baea17f71a2b471b80621bbbdbf0c67"><td class="memItemLeft" align="right" valign="top">step_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a9baea17f71a2b471b80621bbbdbf0c67">getRequiredSteps</a> () const</td></tr>
<tr class="separator:a9baea17f71a2b471b80621bbbdbf0c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392ac306219479df5d4c46f113c4b8db"><td class="memItemLeft" align="right" valign="top">step_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a392ac306219479df5d4c46f113c4b8db">getMaximumSteps</a> () const</td></tr>
<tr class="separator:a392ac306219479df5d4c46f113c4b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e53bfb541285766fd2e4edd5a98cabe"><td class="memItemLeft" align="right" valign="top">step_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a7e53bfb541285766fd2e4edd5a98cabe">getMaximumOrder</a> () const</td></tr>
<tr class="separator:a7e53bfb541285766fd2e4edd5a98cabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e612e1bfa79f6976d12bede1a3dd7a"><td class="memItemLeft" align="right" valign="top">ParamsVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ac7e612e1bfa79f6976d12bede1a3dd7a">params</a> () const</td></tr>
<tr class="separator:ac7e612e1bfa79f6976d12bede1a3dd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f2ee87958fd2de006cfa6924a375b3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab3f2ee87958fd2de006cfa6924a375b3">M</a> () const</td></tr>
<tr class="separator:ab3f2ee87958fd2de006cfa6924a375b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb23f680d57b754324d7bd06b5d78635"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#abb23f680d57b754324d7bd06b5d78635">p</a> () const</td></tr>
<tr class="separator:abb23f680d57b754324d7bd06b5d78635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87d20d3c12ca3d0193581895c51c0c6"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n</a> () const</td></tr>
<tr class="separator:af87d20d3c12ca3d0193581895c51c0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a1aeb3088a057a7351725f90a71ea1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a99a1aeb3088a057a7351725f90a71ea1">d</a> () const</td></tr>
<tr class="separator:a99a1aeb3088a057a7351725f90a71ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad363d37efdee90bdb5b8ef4901ec5c4b"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ad363d37efdee90bdb5b8ef4901ec5c4b">h</a> () const</td></tr>
<tr class="separator:ad363d37efdee90bdb5b8ef4901ec5c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb683ec9adcd0d9e30bc437d7e5e4d11"><td class="memItemLeft" align="right" valign="top">TimePoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#abb683ec9adcd0d9e30bc437d7e5e4d11">tau</a> () const</td></tr>
<tr class="separator:abb683ec9adcd0d9e30bc437d7e5e4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab386a6f606ecb11ab67e6fd490328f75"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab386a6f606ecb11ab67e6fd490328f75">getBasicIntervalLength</a> () const</td></tr>
<tr class="separator:ab386a6f606ecb11ab67e6fd490328f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e43a81cfbab139a0d9bb2b2f738aba"><td class="memItemLeft" align="right" valign="top">TimePoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a06e43a81cfbab139a0d9bb2b2f738aba">t</a> (int i) const</td></tr>
<tr class="separator:a06e43a81cfbab139a0d9bb2b2f738aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3fbd3d1f93eea20c48ac0149d92b1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcapd_1_1ddes_1_1DiscreteTimeGrid.html">Grid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a6c3fbd3d1f93eea20c48ac0149d92b1e">grid</a> () const</td></tr>
<tr class="separator:a6c3fbd3d1f93eea20c48ac0149d92b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1169cb5fcd4487157267fe2fbfaac852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1169cb5fcd4487157267fe2fbfaac852">setCrossingDirection</a> (capd::poincare::CrossingDirection const &amp;<a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a99a1aeb3088a057a7351725f90a71ea1">d</a>)</td></tr>
<tr class="separator:a1169cb5fcd4487157267fe2fbfaac852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8252b3e1fd6c91afb18527676da33e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">DDEq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a8252b3e1fd6c91afb18527676da33e7d">makeEquation</a> ()</td></tr>
<tr class="separator:a8252b3e1fd6c91afb18527676da33e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52803a9ffdd19bc2bc459d548befb289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">C1DDEq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a52803a9ffdd19bc2bc459d548befb289">makeC1Equation</a> ()</td></tr>
<tr class="separator:a52803a9ffdd19bc2bc459d548befb289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0072768890c800dbcac12ba3f65751c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a0072768890c800dbcac12ba3f65751c2">setParams</a> (ParamsVector const &amp;new_params)</td></tr>
<tr class="separator:a0072768890c800dbcac12ba3f65751c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad8e8d583eee78dae8ead667d112030"><td class="memItemLeft" align="right" valign="top">ParamType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#aaad8e8d583eee78dae8ead667d112030">setParam</a> (size_type i, ParamType const &amp;value)</td></tr>
<tr class="separator:aaad8e8d583eee78dae8ead667d112030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec47a31b16f17ed5e1fb1d08e6e2ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">Solver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a3ec47a31b16f17ed5e1fb1d08e6e2ebc">makeSolver</a> (<a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">DDEq</a> const &amp;eq)</td></tr>
<tr class="separator:a3ec47a31b16f17ed5e1fb1d08e6e2ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add871b7bdd6152f5007e17a88751c378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">Solver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#add871b7bdd6152f5007e17a88751c378">makeSolver</a> ()</td></tr>
<tr class="separator:add871b7bdd6152f5007e17a88751c378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5031d4436a3d871ddcc0c5d9f34f73f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">C1Solver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a5031d4436a3d871ddcc0c5d9f34f73f6">makeC1Solver</a> (<a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">C1DDEq</a> const &amp;eq)</td></tr>
<tr class="separator:a5031d4436a3d871ddcc0c5d9f34f73f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44819870756377b851e649c909ad3fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">C1Solver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a44819870756377b851e649c909ad3fea">makeC1Solver</a> ()</td></tr>
<tr class="separator:a44819870756377b851e649c909ad3fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdefa17188bfbf09f15a40e0793b0bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">PoincareMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a5bdefa17188bfbf09f15a40e0793b0bf">makePoincareMap</a> (<a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">Solver</a> &amp;solver, <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> &amp;section)</td></tr>
<tr class="separator:a5bdefa17188bfbf09f15a40e0793b0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84afcdc9656093912b290529718a708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">C1PoincareMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab84afcdc9656093912b290529718a708">makeC1PoincareMap</a> (<a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">C1Solver</a> &amp;solver, <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> &amp;section)</td></tr>
<tr class="separator:ab84afcdc9656093912b290529718a708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de2b2ecf29aba01679877dd5f308f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1de2b2ecf29aba01679877dd5f308f1e">makeSegment</a> (int <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n</a>, Vector v=Vector({})) const</td></tr>
<tr class="separator:a1de2b2ecf29aba01679877dd5f308f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b79ddbfcd15c3c9e711ec3484eb69c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#aa6b79ddbfcd15c3c9e711ec3484eb69c">makeSolution</a> (int <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n</a>, Vector v=Vector({})) const</td></tr>
<tr class="separator:aa6b79ddbfcd15c3c9e711ec3484eb69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34618ac366b58b907f03232e24c37a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a34618ac366b58b907f03232e24c37a30">makeSegment</a> (Vector v=Vector({})) const</td></tr>
<tr class="separator:a34618ac366b58b907f03232e24c37a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10dc0eb6e7d3e7773fadb5f6a6b620a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ae10dc0eb6e7d3e7773fadb5f6a6b620a">makeSolution</a> (Vector v=Vector({})) const</td></tr>
<tr class="separator:ae10dc0eb6e7d3e7773fadb5f6a6b620a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a91480477417d4574c8871fff6ff8ec"><td class="memTemplParams" colspan="2">template&lt;typename OtherMatrixType &gt; </td></tr>
<tr class="memitem:a2a91480477417d4574c8871fff6ff8ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a2a91480477417d4574c8871fff6ff8ec">makeSegment</a> (int <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n</a>, capd::map::Map&lt; OtherMatrixType &gt; f) const</td></tr>
<tr class="separator:a2a91480477417d4574c8871fff6ff8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d933542238eb3952185f1d79fee982d"><td class="memTemplParams" colspan="2">template&lt;typename OtherMatrixType &gt; </td></tr>
<tr class="memitem:a8d933542238eb3952185f1d79fee982d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a8d933542238eb3952185f1d79fee982d">makeSolution</a> (capd::map::Map&lt; OtherMatrixType &gt; f) const</td></tr>
<tr class="separator:a8d933542238eb3952185f1d79fee982d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd66b2f88be7d76b703334163066a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a53fd66b2f88be7d76b703334163066a6">vectorToSolution</a> (Vector const &amp;x) const</td></tr>
<tr class="separator:a53fd66b2f88be7d76b703334163066a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af9bd3f6c8f44e7723d6182c791fad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a9af9bd3f6c8f44e7723d6182c791fad7">makeC1Segment</a> (int <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n</a>, Vector v=Vector({})) const</td></tr>
<tr class="separator:a9af9bd3f6c8f44e7723d6182c791fad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc9a8f9225c7498d230f714b22cfd8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a4cc9a8f9225c7498d230f714b22cfd8f">makeC1Solution</a> (int <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n</a>, Vector v=Vector({})) const</td></tr>
<tr class="separator:a4cc9a8f9225c7498d230f714b22cfd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029d320b141e7867ccca45e7baea2973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a029d320b141e7867ccca45e7baea2973">makeC1Segment</a> (Vector v=Vector({})) const</td></tr>
<tr class="separator:a029d320b141e7867ccca45e7baea2973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb0aab018d610b4b6c492c2cc489ec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1bb0aab018d610b4b6c492c2cc489ec6">makeC1Solution</a> (Vector v=Vector({})) const</td></tr>
<tr class="separator:a1bb0aab018d610b4b6c492c2cc489ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace21394b17bd0f70006573e95cdfaa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ace21394b17bd0f70006573e95cdfaa27">vectorToC1Solution</a> (Vector const &amp;x) const</td></tr>
<tr class="separator:ace21394b17bd0f70006573e95cdfaa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ccea21c5903856fdc0d63107d5355d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ae9ccea21c5903856fdc0d63107d5355d">makeSection</a> (Vector const &amp;s, Scalar const &amp;c)</td></tr>
<tr class="separator:ae9ccea21c5903856fdc0d63107d5355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b5ddea7b4d1520c7d875b0024c8f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ad67b5ddea7b4d1520c7d875b0024c8f6">makeC1Section</a> (Vector const &amp;s, Scalar const &amp;c)</td></tr>
<tr class="separator:ad67b5ddea7b4d1520c7d875b0024c8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6569471ae1250915f1ccb2fcb3c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab8c6569471ae1250915f1ccb2fcb3c3f">integrate</a> (int iters, const <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;initial, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;result, bool use_extension=false)</td></tr>
<tr class="separator:ab8c6569471ae1250915f1ccb2fcb3c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac6681ece9de1adfe87a7e92c29d843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#acac6681ece9de1adfe87a7e92c29d843">integrate</a> (int iters, const <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;initial, bool use_extension=false)</td></tr>
<tr class="separator:acac6681ece9de1adfe87a7e92c29d843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f5d543f176846800dd5d5b572db79f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a44f5d543f176846800dd5d5b572db79f">integrate</a> (int iters, const Vector &amp;initial, Vector &amp;result, bool use_extension=false)</td></tr>
<tr class="separator:a44f5d543f176846800dd5d5b572db79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdcb0ac3ad880f536049d963821f64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1fdcb0ac3ad880f536049d963821f64e">integrate</a> (int iters, const Vector &amp;initial, bool use_extension=false)</td></tr>
<tr class="separator:a1fdcb0ac3ad880f536049d963821f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0959b3cfa7282e3b2ce02c011f12b43d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a0959b3cfa7282e3b2ce02c011f12b43d">integrate</a> (int iters, const <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;initial, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;result, <a class="el" href="classcapd_1_1ddeshelper_1_1PathConfig.html">PathConfig</a> const &amp;outconfig)</td></tr>
<tr class="separator:a0959b3cfa7282e3b2ce02c011f12b43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb24ea056eb78521afe896a628b1d8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#aeb24ea056eb78521afe896a628b1d8dd">integrate</a> (int iters, const Vector &amp;initial, Vector &amp;result, <a class="el" href="classcapd_1_1ddeshelper_1_1PathConfig.html">PathConfig</a> const &amp;outconfig)</td></tr>
<tr class="separator:aeb24ea056eb78521afe896a628b1d8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0e53831aeed823559c4503f274bc53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#acf0e53831aeed823559c4503f274bc53">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> section, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> const &amp;x, double &amp;reachTime, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;Px)</td></tr>
<tr class="separator:acf0e53831aeed823559c4503f274bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4ae4aa27eb335d5ab3da3e30b02e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a21f4ae4aa27eb335d5ab3da3e30b02e3">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> section, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> const &amp;x, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;Px)</td></tr>
<tr class="separator:a21f4ae4aa27eb335d5ab3da3e30b02e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc74e4fdb8a59984b811e379d6bbb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af2bc74e4fdb8a59984b811e379d6bbb8">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> section, Vector const &amp;x, double &amp;reachTime, Vector &amp;Px)</td></tr>
<tr class="separator:af2bc74e4fdb8a59984b811e379d6bbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1175f56219ecc092b229f06af2ab661b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1175f56219ecc092b229f06af2ab661b">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> section, Vector const &amp;x, Vector &amp;Px)</td></tr>
<tr class="separator:a1175f56219ecc092b229f06af2ab661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002928c17e3409f9ec01d290e0819455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a002928c17e3409f9ec01d290e0819455">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> section, Vector const &amp;x, Matrix &amp;initV, double &amp;reachTime, int &amp;steps, Vector &amp;Px, Vector &amp;fPx, Matrix &amp;V, Matrix &amp;DP)</td></tr>
<tr class="separator:a002928c17e3409f9ec01d290e0819455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7578e6873799c2bbca3fc2b1e73c7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ac7578e6873799c2bbca3fc2b1e73c7e0">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> section, Vector const &amp;x0, double &amp;reachTime, Vector &amp;Px, Vector &amp;fPx, Matrix &amp;V, Matrix &amp;DP)</td></tr>
<tr class="separator:ac7578e6873799c2bbca3fc2b1e73c7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e918e2a2afca824527757b420c68047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a2e918e2a2afca824527757b420c68047">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> section, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;X0, Matrix &amp;initV, double &amp;reachTime, int &amp;steps, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;PX, Vector &amp;fPX, Matrix &amp;V, Matrix &amp;DP)</td></tr>
<tr class="separator:a2e918e2a2afca824527757b420c68047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59bd9bb22b2083556c28bb8f1d2a530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#aa59bd9bb22b2083556c28bb8f1d2a530">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> section, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;X0, double &amp;reachTime, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;PX, Matrix &amp;V, Matrix &amp;DP)</td></tr>
<tr class="separator:aa59bd9bb22b2083556c28bb8f1d2a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd85b2e0f823a0c59a716b390ab3565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a0cd85b2e0f823a0c59a716b390ab3565">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> section, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;X0, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;PX, Matrix &amp;V, Matrix &amp;DP)</td></tr>
<tr class="separator:a0cd85b2e0f823a0c59a716b390ab3565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1928e6b166470784e3318693c956b320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1928e6b166470784e3318693c956b320">poincare</a> (<a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> section, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;X0, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;PX, Matrix &amp;DP)</td></tr>
<tr class="separator:a1928e6b166470784e3318693c956b320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e738585341c9b4499d485d9e135b244"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a8e738585341c9b4499d485d9e135b244">refinePeriodic</a> (std::ostream &amp;info, <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> &amp;section, Vector &amp;x, Matrix &amp;V, Matrix &amp;DP)</td></tr>
<tr class="separator:a8e738585341c9b4499d485d9e135b244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3410cf16c85ce6cbe22a3146b21bd93"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ad3410cf16c85ce6cbe22a3146b21bd93">refinePeriodic</a> (std::ostream &amp;info, <a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> &amp;section, <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;X, Matrix &amp;V, Matrix &amp;DP)</td></tr>
<tr class="separator:ad3410cf16c85ce6cbe22a3146b21bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad9378ec191837fe11db6e7bb1decf0"><td class="memTemplParams" colspan="2">template&lt;typename VectorIteratorSpec &gt; </td></tr>
<tr class="memitem:acad9378ec191837fe11db6e7bb1decf0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#acad9378ec191837fe11db6e7bb1decf0">saveData</a> (std::string filepath, VectorIteratorSpec start, VectorIteratorSpec end, std::string extraComment=&quot;&quot;)</td></tr>
<tr class="separator:acad9378ec191837fe11db6e7bb1decf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38542d2431de8e4e4691289fce98f3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ae38542d2431de8e4e4691289fce98f3e">loadSetup</a> (std::string filepath)</td></tr>
<tr class="separator:ae38542d2431de8e4e4691289fce98f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ec92d08ec872cafade5630ce53899c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#aa9ec92d08ec872cafade5630ce53899c">loadData</a> (std::string filepath)</td></tr>
<tr class="separator:aa9ec92d08ec872cafade5630ce53899c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e17191ce743497233be64ebe8c4607"><td class="memItemLeft" align="right" valign="top"><a id="a96e17191ce743497233be64ebe8c4607"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawMap</b> (<a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> const &amp;solution, <a class="el" href="classcapd_1_1ddeshelper_1_1PathConfig.html">PathConfig</a> const &amp;outconfig)</td></tr>
<tr class="separator:a96e17191ce743497233be64ebe8c4607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ca908f9efbaf8593e5e5e011a35743"><td class="memTemplParams" colspan="2"><a id="a73ca908f9efbaf8593e5e5e011a35743"></a>
template&lt;typename SolutionT &gt; </td></tr>
<tr class="memitem:a73ca908f9efbaf8593e5e5e011a35743"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drawSolution</b> (std::string dirpath, std::string filename, SolutionT const &amp;X, double tshift=0.) const</td></tr>
<tr class="separator:a73ca908f9efbaf8593e5e5e011a35743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81a2fdc95331725f39fb883ae3c6bcb"><td class="memItemLeft" align="right" valign="top"><a id="ab81a2fdc95331725f39fb883ae3c6bcb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>drawSolution</b> (std::string dirpath, std::string filename, Vector const &amp;x, double tshift=0.) const</td></tr>
<tr class="separator:ab81a2fdc95331725f39fb883ae3c6bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabac34e663b12e028b7b91752ab6fd54"><td class="memTemplParams" colspan="2"><a id="aabac34e663b12e028b7b91752ab6fd54"></a>
template&lt;typename SolutionT &gt; </td></tr>
<tr class="memitem:aabac34e663b12e028b7b91752ab6fd54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drawSolution</b> (std::string filename, SolutionT const &amp;X, double tshift=0.) const</td></tr>
<tr class="separator:aabac34e663b12e028b7b91752ab6fd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b0600b35a19e5b0015d1c1b4a2cb0b"><td class="memTemplParams" colspan="2"><a id="a46b0600b35a19e5b0015d1c1b4a2cb0b"></a>
template&lt;typename SolutionT &gt; </td></tr>
<tr class="memitem:a46b0600b35a19e5b0015d1c1b4a2cb0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drawSolution</b> (<a class="el" href="classcapd_1_1ddeshelper_1_1PathConfig.html">PathConfig</a> const &amp;paths, SolutionT const &amp;X, double tshift=0.) const</td></tr>
<tr class="separator:a46b0600b35a19e5b0015d1c1b4a2cb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849902e058a8aa22119b5604114896b1"><td class="memTemplParams" colspan="2"><a id="a849902e058a8aa22119b5604114896b1"></a>
template&lt;typename SolutionT &gt; </td></tr>
<tr class="memitem:a849902e058a8aa22119b5604114896b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drawDelayMap</b> (std::string dirpath, std::string filename, SolutionT const &amp;X) const</td></tr>
<tr class="separator:a849902e058a8aa22119b5604114896b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae921f5631550c15774e6614f5a5a9454"><td class="memTemplParams" colspan="2"><a id="ae921f5631550c15774e6614f5a5a9454"></a>
template&lt;typename SolutionT &gt; </td></tr>
<tr class="memitem:ae921f5631550c15774e6614f5a5a9454"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drawDelayMap</b> (std::string filename, SolutionT const &amp;X) const</td></tr>
<tr class="separator:ae921f5631550c15774e6614f5a5a9454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e2735a480fdf7cd331c32653827ad"><td class="memTemplParams" colspan="2"><a id="a7a8e2735a480fdf7cd331c32653827ad"></a>
template&lt;typename SolutionT &gt; </td></tr>
<tr class="memitem:a7a8e2735a480fdf7cd331c32653827ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drawDelayMap</b> (<a class="el" href="classcapd_1_1ddeshelper_1_1PathConfig.html">PathConfig</a> const &amp;paths, SolutionT const &amp;X) const</td></tr>
<tr class="separator:a7a8e2735a480fdf7cd331c32653827ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d17de5ba99e02ecb29a19f54099438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">NonrigorousHelper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a08d17de5ba99e02ecb29a19f54099438">setExperimentalRenormalizeVariational</a> (bool v)</td></tr>
<tr class="separator:a08d17de5ba99e02ecb29a19f54099438"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aab438b17a3fe1c34375f2476b7242104"><td class="memItemLeft" align="right" valign="top"><a id="aab438b17a3fe1c34375f2476b7242104"></a>
static const size_type&#160;</td><td class="memItemRight" valign="bottom"><b>PARAMS_COUNT</b> = EqSpec::getParamsCount() + delaysSpec</td></tr>
<tr class="separator:aab438b17a3fe1c34375f2476b7242104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f6fa0a73bcac671f1d5d933a7f69ad"><td class="memItemLeft" align="right" valign="top"><a id="ad8f6fa0a73bcac671f1d5d933a7f69ad"></a>
static const size_type&#160;</td><td class="memItemRight" valign="bottom"><b>DIMENSION</b> = EqSpec::imageDimension()</td></tr>
<tr class="separator:ad8f6fa0a73bcac671f1d5d933a7f69ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename EqSpec, int delaysSpec = 1, typename MatrixSpec = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt;<br />
class capd::ddeshelper::NonrigorousHelper&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;</h3>

<p>A helper class that made all the fuzzy boilerplate for you, so you do not need to know various things by yourself.</p>
<p>It provides functions like integrate and poincare to compute images of the initial functions under your own equations. You only need to supply the equation and the number of delays in the system.</p>
<p>The Equation (template</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EqSpec)</td><td>must be a class of special form. See programs/examples for usage and examples and/or <a class="el" href="SampleEqns_8h_source.html">include/capd/ddes/SampleEqns.h</a> for more information. A general form is as follows:</td></tr>
  </table>
  </dd>
</dl>
<p>struct MyEquation{ typedef unsigned int size_type; // this is required to know what the three static functions return. This is usually unsigned int. At the cost of some warnings, you can use int as well. typedef double ParamType; // the type to hold parameters. I usually make it a template parameter to be able to use in both rigorous and non-rigorous setting. typedef capd::vectalg::Vector&lt;ParamType, 0&gt; ParamsVectorType; // this defines the type to hold a vector of parameters</p>
<p>MyEquation(ParamsVectorType const &amp; params); // we require that the equation has a canstructor that gets parameters vector. MyEquation(); // default constructor, it must be defined, as we have another constructor (with params vector). All other constructors are entirely up to you. static size_type imageDimension(); // output dimension of the internal map (usually, the dimension d of the space for x(t) variable) static size_type dimension(); // input dimension of the internal map (usually, imageDimension() * (number_of_delays+1)) static size_type getParamsCount(); // number of parameters to fully configure the equation, but without delays! Depends on the equation, e.g. Mackey-Glass has 3 parameters, except the delay. static std::string show(); // this is used in debug output, it can return empty string if you wish.</p>
<p>// this is the ost important part // it takes t -time, x - the collection of values at 0 and consecutive delays, then // it should compute the value of R.h.s f(x(0), x(t_1), ... ) in fx. // the dimension of x is given by dimension(), the // dimension of fx is given by imageDimension(); template&lt;typename RealSpec, typename InVectorSpec, typename OutVectorSpec&gt; void operator()(const RealSpec&amp; t, const InVectorSpec x, OutVectorSpec&amp; fx) const; };</p>
<p>You might also supply Matrix and Vector type, but the dfault versions works ok.</p>
<p>As of now, it can only handle discrete delay differential equations in the form of</p>
<p>x'(t) = f(x(t), x(t-\tau_1), ... , x(t-tau_m))</p>
<p>where tau_i's matches time points of the integration grid.</p>
<p>C1-versions allows to do nonrigorous computations of the variational equation associated to the original equation, allowing e.g. to apply Newton method to find better candidates.</p>
<p>TODO: (IMPORTANT) Currently it only support one delay!!!!!! TODO: (URGENT?) DEV: make sure all const qualifiers are put in the right places! TODO: (FUTURE) move implementation to hpp file to shorten this for end user TODO: (FUTURE): the normal and C^1 versions are totaly separated. Rethink if they can reuse some code, because there is a lot of repetition... </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a99d6006c4e704bb1c1f84b2fb17c4146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d6006c4e704bb1c1f84b2fb17c4146">&#9670;&nbsp;</a></span>NonrigorousHelper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::<a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">NonrigorousHelper</a> </td>
          <td>(</td>
          <td class="paramtype">ParamsVector&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>reqSteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>maxSteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxOrder</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>you need to call at least one of the constructors and then use the setup variable</p>
<p>This constructor takes parameters vector:</p>
<p>(q_1, ..., q_k, tau_1, ... tau_m)</p>
<p>where q_i's are the parameters of the equation (r.h.s f : \R^{d*(m+1)} \to \R^d of the DDE) and tau_i's are the delays, so that the equation is</p>
<p>x'(t) = f(x(t), x(t-tau_1), ...)</p>
<p>p, n - are parameters of the (p,n)-representation of the functions. p is the number of grid points in the basic interval [-tau, 0], tau = max(tau_i) n is the order of the jet at each point. See papers for more details. </p>

</div>
</div>
<a id="ac1e62e94b910ad0bd7af27293959c938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e62e94b910ad0bd7af27293959c938">&#9670;&nbsp;</a></span>NonrigorousHelper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::<a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">NonrigorousHelper</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>reqSteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>maxSteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxOrder</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>similar to the first one, but reads the parameters and p and n from a given file. </p>

</div>
</div>
<a id="a0a6d44d77612316f0384db78f7c3eff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6d44d77612316f0384db78f7c3eff2">&#9670;&nbsp;</a></span>NonrigorousHelper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::<a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">NonrigorousHelper</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>reqSteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>maxSteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>maxOrder</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>similar to the second one, but user gives istream instead of filepath </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a99a1aeb3088a057a7351725f90a71ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a1aeb3088a057a7351725f90a71ea1">&#9670;&nbsp;</a></span>d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::d </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>dimension of the 'ambient' space, i.e. the dimension of x(t) for a fixed t </p>

</div>
</div>
<a id="ab386a6f606ecb11ab67e6fd490328f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab386a6f606ecb11ab67e6fd490328f75">&#9670;&nbsp;</a></span>getBasicIntervalLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::getBasicIntervalLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the size of the longest interval but as a Real value, not TimePoint </p>

</div>
</div>
<a id="a7e53bfb541285766fd2e4edd5a98cabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e53bfb541285766fd2e4edd5a98cabe">&#9670;&nbsp;</a></span>getMaximumOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">step_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::getMaximumOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns <br  />
 </p>

</div>
</div>
<a id="a392ac306219479df5d4c46f113c4b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392ac306219479df5d4c46f113c4b8db">&#9670;&nbsp;</a></span>getMaximumSteps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">step_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::getMaximumSteps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>docs for setter </dd></dl>

</div>
</div>
<a id="a9baea17f71a2b471b80621bbbdbf0c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baea17f71a2b471b80621bbbdbf0c67">&#9670;&nbsp;</a></span>getRequiredSteps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">step_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::getRequiredSteps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>docs for setter </dd></dl>

</div>
</div>
<a id="a6c3fbd3d1f93eea20c48ac0149d92b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3fbd3d1f93eea20c48ac0149d92b1e">&#9670;&nbsp;</a></span>grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcapd_1_1ddes_1_1DiscreteTimeGrid.html">Grid</a>&amp; <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::grid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the internal grid used by this helper </p>

</div>
</div>
<a id="ad363d37efdee90bdb5b8ef4901ec5c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad363d37efdee90bdb5b8ef4901ec5c4b">&#9670;&nbsp;</a></span>h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::h </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns basic grid size step h := tau/p </p>

</div>
</div>
<a id="acac6681ece9de1adfe87a7e92c29d843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac6681ece9de1adfe87a7e92c29d843">&#9670;&nbsp;</a></span>integrate() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_extension</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab8c6569471ae1250915f1ccb2fcb3c3f">integrate(int, const Solution&amp;, Solution&amp;, bool)</a> </dd></dl>

</div>
</div>
<a id="ab8c6569471ae1250915f1ccb2fcb3c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6569471ae1250915f1ccb2fcb3c3f">&#9670;&nbsp;</a></span>integrate() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_extension</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just integrate the solution.</p>
<p>Integrates for time T = iters * tau_max / p = iters * h. The value h is the step size of the method / grid</p>
<p>If</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>&lt; 0 then it will be converted to full delays! The DDEs cannot be integrated backward in time!</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution on the whole integration time.</dd></dl>
<p>The initial solution segment must have the same grid as the Helper, otherwise the exception will be thrown. It is best to make a solution with <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#aa6b79ddbfcd15c3c9e711ec3484eb69c">makeSolution()</a> methods of the helper.</p>
<p>If</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_extension</td><td>is set to true, then the more accurate results will be produced due to use of extension algorithm described in FoCM 2023 paper. But then, the returned full Solution will have varying degree of the representation at various jets.</td></tr>
  </table>
  </dd>
</dl>
<p>In</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return</td><td>it returns the last segment of the solution in the</td></tr>
    <tr><td class="paramname">result.</td><td>The structure of result will be preserved, i.e. if extension is used, and the structure of result is the same as initial, then the result still have the same structure as initial. This might be useful for iterating maps.</td></tr>
  </table>
  </dd>
</dl>
<p>TODO: (FUTURE, IMPORTANT?) As in CAPD, create Timemap class to handle this in general... </p>

</div>
</div>
<a id="a0959b3cfa7282e3b2ce02c011f12b43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0959b3cfa7282e3b2ce02c011f12b43d">&#9670;&nbsp;</a></span>integrate() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddeshelper_1_1PathConfig.html">PathConfig</a> const &amp;&#160;</td>
          <td class="paramname"><em>outconfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>integrate, save output to files and draw the solution. See other versions for more information on input and output.</p>
<p>The variable outconfig holds a pair of strings that define paths to where store the results of the computations. See documentation there.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>For backward compatibility... </dd></dl>

</div>
</div>
<a id="a1fdcb0ac3ad880f536049d963821f64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdcb0ac3ad880f536049d963821f64e">&#9670;&nbsp;</a></span>integrate() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_extension</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>just integrate the solution and return the solution</p>
<p>initial can be either of (1) d-dimension (\R^d) or (2) the M(d,p,n)-dimension (see papers) In the (1) case it integrates initial function x_0(s) == initial for all s \in [-tau, 0] In the (2) case it constructs initial function from data stored in x0 (the order of coefficients in this vector is described elsewhere (see papers for example). But suppling it by hand is extremely cumbersome. It is best to use output of other functions o get initials in this form.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>It is better to use function based on Solution parameters </dd></dl>

</div>
</div>
<a id="a44f5d543f176846800dd5d5b572db79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f5d543f176846800dd5d5b572db79f">&#9670;&nbsp;</a></span>integrate() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_extension</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>just integrate the solution and return the solution</p>
<p>initial can be either of (1) d-dimension (\R^d) or (2) the M(d,p,n)-dimension (see papers) In the (1) case it integrates initial function x_0(s) == initial for all s \in [-tau, 0] In the (2) case it constructs initial function from data stored in x0 (the order of coefficients in this vector is described elsewhere (see papers for example). But suppling it by hand is very cumbersome. It is best to use output of other functions o get initials in this form.</p>
<p>Integrates for time T = iters * tau_max / p = iters * h. The value h is the step size of the method / grid</p>
<p>In the result the last segment x_T from the solution in the vector format. Can be used as an input to the next <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab8c6569471ae1250915f1ccb2fcb3c3f">integrate()</a> procedure, to create an initial solution curve, or in other functions from the helper (e.g. poincare).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>It is better to use function based on Solution parameters </dd></dl>

</div>
</div>
<a id="aeb24ea056eb78521afe896a628b1d8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb24ea056eb78521afe896a628b1d8dd">&#9670;&nbsp;</a></span>integrate() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddeshelper_1_1PathConfig.html">PathConfig</a> const &amp;&#160;</td>
          <td class="paramname"><em>outconfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>For backward compatibility... </dd></dl>

</div>
</div>
<a id="aa9ec92d08ec872cafade5630ce53899c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ec92d08ec872cafade5630ce53899c">&#9670;&nbsp;</a></span>loadData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Vector&gt; <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::loadData </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>load data only if compatible with setup </p>

</div>
</div>
<a id="ae38542d2431de8e4e4691289fce98f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38542d2431de8e4e4691289fce98f3e">&#9670;&nbsp;</a></span>loadSetup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec, typename MatrixSpec , typename VectorSpec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::loadSetup </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO: (URGENT): docs! </p>

</div>
</div>
<a id="ab3f2ee87958fd2de006cfa6924a375b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f2ee87958fd2de006cfa6924a375b3">&#9670;&nbsp;</a></span>M()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the intrinsic dimension of the (d,p,n)-representation. This is the constant M = M(d, p, n) from papers. It is usually a big number = O(d*p*n) </p>

</div>
</div>
<a id="a52803a9ffdd19bc2bc459d548befb289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52803a9ffdd19bc2bc459d548befb289">&#9670;&nbsp;</a></span>makeC1Equation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">C1DDEq</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Equation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T</p><dl class="section see"><dt>See also</dt><dd>the other. This is to be used with C1*** types. <br  />
 </dd></dl>

</div>
</div>
<a id="ab84afcdc9656093912b290529718a708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84afcdc9656093912b290529718a708">&#9670;&nbsp;</a></span>makeC1PoincareMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">C1PoincareMap</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1PoincareMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">C1Solver</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> &amp;&#160;</td>
          <td class="paramname"><em>section</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This creates a PoincareMap. See the other version for more docs.</p>
<p>This version creates a Poincare map that can also compute Jacobian and Monodromy matrix (approximations). Those are computationally expensive, so if you do not need them, then the other version is much faster. </p>

</div>
</div>
<a id="ad67b5ddea7b4d1520c7d875b0024c8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b5ddea7b4d1520c7d875b0024c8f6">&#9670;&nbsp;</a></span>makeC1Section()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Section </td>
          <td>(</td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar const &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>same as <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ae9ccea21c5903856fdc0d63107d5355d">makeSection()</a>, but returns a datatype needed for computation of poincare map with monodromy and jacobian of the poincare map, </p><dl class="section see"><dt>See also</dt><dd>the relevant <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a5bdefa17188bfbf09f15a40e0793b0bf">makePoincareMap()</a>. </dd></dl>

</div>
</div>
<a id="a9af9bd3f6c8f44e7723d6182c791fad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af9bd3f6c8f44e7723d6182c791fad7">&#9670;&nbsp;</a></span>makeC1Segment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Segment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version is suitable for approximate C^1 computations - computing Jacobian of a Poincare/Time map.</p>
<p>makes a segment of solution over [-tau, 0] of order n, with a given value. If the dim(v) == d (dimension of the 'ambient' space), then the constant solution will be made. If dim(v) = <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab3f2ee87958fd2de006cfa6924a375b3">M()</a>, then a solution with the given data is produced.</p>
<p>Without the v parameter, it creates a zero solution (v = {0,..,0}). Without n, it creates solution with order m_n as set in this Helper. </p>

</div>
</div>
<a id="a029d320b141e7867ccca45e7baea2973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029d320b141e7867ccca45e7baea2973">&#9670;&nbsp;</a></span>makeC1Segment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Segment </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a segment over [-tau, 0] with order n as set in this helper. See other @method <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1de2b2ecf29aba01679877dd5f308f1e">makeSegment()</a> </p>

</div>
</div>
<a id="a4cc9a8f9225c7498d230f714b22cfd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc9a8f9225c7498d230f714b22cfd8f">&#9670;&nbsp;</a></span>makeC1Solution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Solution </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>just a rename of makeSegment, for backward compatibility. </p>

</div>
</div>
<a id="a1bb0aab018d610b4b6c492c2cc489ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb0aab018d610b4b6c492c2cc489ec6">&#9670;&nbsp;</a></span>makeC1Solution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Solution </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>just a rename of makeSegment, for backward compatibility. </p>

</div>
</div>
<a id="a44819870756377b851e649c909ad3fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44819870756377b851e649c909ad3fea">&#9670;&nbsp;</a></span>makeC1Solver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">C1Solver</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It uses the other version with the current equation (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a8252b3e1fd6c91afb18527676da33e7d">makeEquation()</a>). </dd></dl>

</div>
</div>
<a id="a5031d4436a3d871ddcc0c5d9f34f73f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5031d4436a3d871ddcc0c5d9f34f73f6">&#9670;&nbsp;</a></span>makeC1Solver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">C1Solver</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeC1Solver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">C1DDEq</a> const &amp;&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#add871b7bdd6152f5007e17a88751c378">makeSolver()</a>.</dd></dl>
<p>This version can be used to compute monodromy matrix along the solution. </p>

</div>
</div>
<a id="a8252b3e1fd6c91afb18527676da33e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8252b3e1fd6c91afb18527676da33e7d">&#9670;&nbsp;</a></span>makeEquation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">DDEq</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeEquation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This creates an object representing the equation for the current value of parameters set in the helper. </p>

</div>
</div>
<a id="a5bdefa17188bfbf09f15a40e0793b0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdefa17188bfbf09f15a40e0793b0bf">&#9670;&nbsp;</a></span>makePoincareMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEBasicPoincareMap.html">PoincareMap</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makePoincareMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">Solver</a> &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> &amp;&#160;</td>
          <td class="paramname"><em>section</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This creates a PoincareMap.</p>
<p>Warning: the solver and section are passed as references, so they need to be non-temporary variables. You cannot do makePoincare(<a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#add871b7bdd6152f5007e17a88751c378">makeSolver()</a>, <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ae9ccea21c5903856fdc0d63107d5355d">makeSection()</a>); You need to have: auto solver = <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#add871b7bdd6152f5007e17a88751c378">makeSolver()</a>; auto section = <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ae9ccea21c5903856fdc0d63107d5355d">makeSection()</a>; auto pm = makePoincareMap(solver, section); </p>

</div>
</div>
<a id="ae9ccea21c5903856fdc0d63107d5355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ccea21c5903856fdc0d63107d5355d">&#9670;&nbsp;</a></span>makeSection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSection </td>
          <td>(</td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar const &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>makes a section and stores it in out_section</p>
<p>if dim(s) == d, then we setup section in the coordinate x(0) . s = c otherwise we set full-space section s . x_0 = c </p>

</div>
</div>
<a id="a2a91480477417d4574c8871fff6ff8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a91480477417d4574c8871fff6ff8ec">&#9670;&nbsp;</a></span>makeSegment() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSegment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">capd::map::Map&lt; OtherMatrixType &gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>makes a segment of solution by evaluating a CAPD Map \R \to \R^d. The map must be of this shape! You cannot add more dimentsion, or have more variables! This is an example for d = 3: </p><pre class="fragment">    capd::DMap f("var:t;fun:t,2t,t*(t-1);");
</pre><p>you can have aparmeters, but remember to set them before sending to this metod: </p><pre class="fragment">    capd::DMap f("par:a,b;var:t;fun:a*t,b*t,a*t*(b*t-1);");
    f.set_parameter("a", 1);
    f.set_parameter("b", 2);
</pre> 
</div>
</div>
<a id="a1de2b2ecf29aba01679877dd5f308f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de2b2ecf29aba01679877dd5f308f1e">&#9670;&nbsp;</a></span>makeSegment() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSegment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>makes a segment of solution over [-tau, 0] of order n, with a given value. If the dim(v) == d (dimension of the 'ambient' space), then the constant solution will be made. If dim(v) = <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab3f2ee87958fd2de006cfa6924a375b3">M()</a>, then a solution with the given data is produced.</p>
<p>Without the v parameter, it creates a zero solution (v = {0,..,0}). Without n, it creates solution with order m_n as set in this Helper. </p>

</div>
</div>
<a id="a34618ac366b58b907f03232e24c37a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34618ac366b58b907f03232e24c37a30">&#9670;&nbsp;</a></span>makeSegment() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSegment </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a constant value segment over [-tau, 0] with representation order n as set in this helper. See other @method <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1de2b2ecf29aba01679877dd5f308f1e">makeSegment()</a> </p>

</div>
</div>
<a id="a8d933542238eb3952185f1d79fee982d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d933542238eb3952185f1d79fee982d">&#9670;&nbsp;</a></span>makeSolution() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSolution </td>
          <td>(</td>
          <td class="paramtype">capd::map::Map&lt; OtherMatrixType &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>just a rename of makeSegment, for backward compatibility. </p>

</div>
</div>
<a id="aa6b79ddbfcd15c3c9e711ec3484eb69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b79ddbfcd15c3c9e711ec3484eb69c">&#9670;&nbsp;</a></span>makeSolution() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSolution </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>just a rename of makeSegment, for backward compatibility. </p>

</div>
</div>
<a id="ae10dc0eb6e7d3e7773fadb5f6a6b620a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10dc0eb6e7d3e7773fadb5f6a6b620a">&#9670;&nbsp;</a></span>makeSolution() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSolution </td>
          <td>(</td>
          <td class="paramtype">Vector&#160;</td>
          <td class="paramname"><em>v</em> = <code>Vector({})</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>just a rename of makeSegment, for backward compatibility. </p>

</div>
</div>
<a id="add871b7bdd6152f5007e17a88751c378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add871b7bdd6152f5007e17a88751c378">&#9670;&nbsp;</a></span>makeSolver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">Solver</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It uses the other version with the current equation (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a8252b3e1fd6c91afb18527676da33e7d">makeEquation()</a>). </dd></dl>

</div>
</div>
<a id="a3ec47a31b16f17ed5e1fb1d08e6e2ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec47a31b16f17ed5e1fb1d08e6e2ebc">&#9670;&nbsp;</a></span>makeSolver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDENonrigorousTaylorSolver.html">Solver</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::makeSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1BasicDiscreteDelaysFunctionalMap.html">DDEq</a> const &amp;&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This creates a raw solver, if you want to do nonstandard tasks and have an Equation made on the side. If you want just to integrate initial values, consider using iterate() or <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#acf0e53831aeed823559c4503f274bc53">poincare()</a> instead. </p>

</div>
</div>
<a id="af87d20d3c12ca3d0193581895c51c0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87d20d3c12ca3d0193581895c51c0c6">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the order of the representation of the solutions used in this helper </p>

</div>
</div>
<a id="abb23f680d57b754324d7bd06b5d78635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb23f680d57b754324d7bd06b5d78635">&#9670;&nbsp;</a></span>p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the grid size, i.e. into how many subintervals we divide basic delay </p>

</div>
</div>
<a id="ac7e612e1bfa79f6976d12bede1a3dd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e612e1bfa79f6976d12bede1a3dd7a">&#9670;&nbsp;</a></span>params()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParamsVector <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::params </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the parameters of the r.h.s of the DDE set for this helper </p>

</div>
</div>
<a id="a1928e6b166470784e3318693c956b320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1928e6b166470784e3318693c956b320">&#9670;&nbsp;</a></span>poincare() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;&#160;</td>
          <td class="paramname"><em>X0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>PX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: (URGENT!!!) docs </p>

</div>
</div>
<a id="a0cd85b2e0f823a0c59a716b390ab3565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd85b2e0f823a0c59a716b390ab3565">&#9670;&nbsp;</a></span>poincare() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;&#160;</td>
          <td class="paramname"><em>X0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>PX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: (URGENT!!!) docs </p>

</div>
</div>
<a id="aa59bd9bb22b2083556c28bb8f1d2a530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59bd9bb22b2083556c28bb8f1d2a530">&#9670;&nbsp;</a></span>poincare() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;&#160;</td>
          <td class="paramname"><em>X0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>reachTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>PX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: (URGENT!!!) docs </p>

</div>
</div>
<a id="a2e918e2a2afca824527757b420c68047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e918e2a2afca824527757b420c68047">&#9670;&nbsp;</a></span>poincare() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> const &amp;&#160;</td>
          <td class="paramname"><em>X0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>initV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>reachTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>PX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>fPX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if you do not know what initV is, then you should probably stick to using the other C1Solution <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#acf0e53831aeed823559c4503f274bc53">poincare()</a> method (without initV). </p>

</div>
</div>
<a id="a002928c17e3409f9ec01d290e0819455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002928c17e3409f9ec01d290e0819455">&#9670;&nbsp;</a></span>poincare() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>initV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>reachTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>Px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>fPx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if you do not know what initV is, then you should probably stick to using the other C1Solution <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#acf0e53831aeed823559c4503f274bc53">poincare()</a> method (without initV). </p>

</div>
</div>
<a id="ac7578e6873799c2bbca3fc2b1e73c7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7578e6873799c2bbca3fc2b1e73c7e0">&#9670;&nbsp;</a></span>poincare() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>reachTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>Px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>fPx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>computes poincare map and the (approximate) solution to the variational equation on the coefficients in V it returns the monodromy matrix, that is D_x \varph(t_P(x0), x) in DP you get D \varphi(t_p(x), x) (sic! the difference in t_p argument) in fPx you get the value of the "vector field" at P(x0) this is not straightforward as in ODE that is for ODE you have fPx = f(P(x0)), where f is r.h.s. of the ODE. But for DDE you do not have r.h.s for all of the points in [-tau, 0] But it can be shown, that if $t_p \ge tau$ then $fPx = (Px)'$ (note Px : [-tau,0] \to \R^d is a function of time, so it can be differentiated) </p>

</div>
</div>
<a id="acf0e53831aeed823559c4503f274bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0e53831aeed823559c4503f274bc53">&#9670;&nbsp;</a></span>poincare() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>reachTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>Px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a poincare map, starting from point x, until section s is crossed in the direction set for this Helper. The result will be in Px. The (p, \eta)-structure of Px is preserved (see papers, references). the time to reach section is in reachTime.</p>
<p>The reachTime will be at least base grid step h * requiredSteps, which are set for this Helper. </p>

</div>
</div>
<a id="a21f4ae4aa27eb335d5ab3da3e30b02e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f4ae4aa27eb335d5ab3da3e30b02e3">&#9670;&nbsp;</a></span>poincare() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>Px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>poincare(JetSection, Solution const&amp;, double, Solution&amp;) </dd></dl>

</div>
</div>
<a id="af2bc74e4fdb8a59984b811e379d6bbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bc74e4fdb8a59984b811e379d6bbb8">&#9670;&nbsp;</a></span>poincare() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>reachTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>Px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The simples computation of poincare map, without extra data. This version operates on raw vectors (they need to comply with the dimension <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#ab3f2ee87958fd2de006cfa6924a375b3">M()</a> of the Helper. </p>

</div>
</div>
<a id="a1175f56219ecc092b229f06af2ab661b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1175f56219ecc092b229f06af2ab661b">&#9670;&nbsp;</a></span>poincare() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::poincare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a>&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>Px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the simplest computation of poincare map, without extra data (even without return time) </p>

</div>
</div>
<a id="a8e738585341c9b4499d485d9e135b244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e738585341c9b4499d485d9e135b244">&#9670;&nbsp;</a></span>refinePeriodic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::refinePeriodic </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">C1JetSection</a> &amp;&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to refine a candidate periodic orbit with a Newton method.</p>
<p>First parameter is to get some text info back during the process, you can pass std::cout there or some std::ostringstream to ignore it.</p>
<p>For technical reasons section must be of type C1JetSection, not JetSection.</p>
<p>The V and DP matrices are the monodromy and Jacobian of Poincare map, respectively. They might be helpful in finding good candidate for section coordinates. </p><dl class="section see"><dt>See also</dt><dd>periodicCoordinates(), where an example procedure described in 2023 FOCM paper is implemented.</dd></dl>
<p>It returns the difference between candidate x and P(x) (in basic euclidean norm on the vector representations!).</p>
<p>You should iterate the method for desired number of iterates or until desired accuracy is obtained. </p>

</div>
</div>
<a id="ad3410cf16c85ce6cbe22a3146b21bd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3410cf16c85ce6cbe22a3146b21bd93">&#9670;&nbsp;</a></span>refinePeriodic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::refinePeriodic </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEJetSection.html">JetSection</a> &amp;&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>DP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>refines, by one Newton iteration, the X if it is a candidate for periodic orbit on the given section.</p>
<p>If X is not on the section or far from the true solution, then the method might fail.</p>
<p>You should iterate the method for desired number of iterates or until desired accuracy is obtained.</p>
<p>The V is the Monodromy matrix and DP is the Jacobian of the Poincare Map. They can be used to obtain good coordinates on the section.</p>
<p>TODO: (FUTURE) this will only work if the segment X is of uniform order <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#af87d20d3c12ca3d0193581895c51c0c6">n()</a>. This should be corrected to work for any... </p>

</div>
</div>
<a id="acad9378ec191837fe11db6e7bb1decf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad9378ec191837fe11db6e7bb1decf0">&#9670;&nbsp;</a></span>saveData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorIteratorSpec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::saveData </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIteratorSpec&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIteratorSpec&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>extraComment</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: (URGENT): docs! </p>

</div>
</div>
<a id="a1169cb5fcd4487157267fe2fbfaac852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1169cb5fcd4487157267fe2fbfaac852">&#9670;&nbsp;</a></span>setCrossingDirection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::setCrossingDirection </td>
          <td>(</td>
          <td class="paramtype">capd::poincare::CrossingDirection const &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the crossing directions for PoincareMaps used in this helper subroutines </p>

</div>
</div>
<a id="a08d17de5ba99e02ecb29a19f54099438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d17de5ba99e02ecb29a19f54099438">&#9670;&nbsp;</a></span>setExperimentalRenormalizeVariational()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">NonrigorousHelper</a>&amp; <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::setExperimentalRenormalizeVariational </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is DEVELOPMENTAL, pleas do not use </p>

</div>
</div>
<a id="affebb75e5ec3a8b29d06a39b9299521f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affebb75e5ec3a8b29d06a39b9299521f">&#9670;&nbsp;</a></span>setMaximumOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::setMaximumOrder </td>
          <td>(</td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>maxOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control_steps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the maximum allowed order of the expanded representation as described in the 2023 FOCM paper. it can be as large as you want. But please remember that the expansions occur by one every p steps (full delay). Also, the size makes computations expensive very fast. </p>

</div>
</div>
<a id="a7c70a51464c0cfe5b69944e68b1281aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c70a51464c0cfe5b69944e68b1281aa">&#9670;&nbsp;</a></span>setMaximumSteps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::setMaximumSteps </td>
          <td>(</td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>maxSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control_steps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the maximum allowed steps. This prevents the infinite loops when the solution goes astray </p>

</div>
</div>
<a id="aaad8e8d583eee78dae8ead667d112030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad8e8d583eee78dae8ead667d112030">&#9670;&nbsp;</a></span>setParam()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParamType <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::setParam </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParamType const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the value of some parameter. Can't change value of the delay! Returns the previous value of the param. </p>

</div>
</div>
<a id="a0072768890c800dbcac12ba3f65751c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0072768890c800dbcac12ba3f65751c2">&#9670;&nbsp;</a></span>setParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::setParams </td>
          <td>(</td>
          <td class="paramtype">ParamsVector const &amp;&#160;</td>
          <td class="paramname"><em>new_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the value of the current params (but not the delays!) </p>

</div>
</div>
<a id="a0f364979bd5cc242a0e65aa87ee32b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f364979bd5cc242a0e65aa87ee32b75">&#9670;&nbsp;</a></span>setRequiredSteps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::setRequiredSteps </td>
          <td>(</td>
          <td class="paramtype">step_type&#160;</td>
          <td class="paramname"><em>reqSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control_steps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this controls how many steps are needed before the section crossing would be detected when computing poincare maps. This is important more in the rigorous setting, but to have consistent computations you might want to keep it the same. The helper will set the right (long enough as in papers) number of steps for you. Please make it at least p steps if you want to change it. </p>

</div>
</div>
<a id="a06e43a81cfbab139a0d9bb2b2f738aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e43a81cfbab139a0d9bb2b2f738aba">&#9670;&nbsp;</a></span>t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TimePoint <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::t </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the i-th grid point, where e.g. t(-p) = -tau, t(0) = 0 </p>

</div>
</div>
<a id="abb683ec9adcd0d9e30bc437d7e5e4d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb683ec9adcd0d9e30bc437d7e5e4d11">&#9670;&nbsp;</a></span>tau()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TimePoint <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::tau </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns the basic interval (the longest one) </p>

</div>
</div>
<a id="ace21394b17bd0f70006573e95cdfaa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace21394b17bd0f70006573e95cdfaa27">&#9670;&nbsp;</a></span>vectorToC1Solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">C1Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::vectorToC1Solution </td>
          <td>(</td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>use makeJacSegment() instead! </dd></dl>

</div>
</div>
<a id="a53fd66b2f88be7d76b703334163066a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fd66b2f88be7d76b703334163066a6">&#9670;&nbsp;</a></span>vectorToSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EqSpec , int delaysSpec = 1, typename MatrixSpec  = capd::vectalg::Matrix&lt;typename EqSpec::ParamType, 0, 0&gt;, typename VectorSpec  = capd::vectalg::Vector&lt;typename EqSpec::ParamType, 0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcapd_1_1ddes_1_1DDEPiecewisePolynomialCurve.html">Solution</a> <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html">capd::ddeshelper::NonrigorousHelper</a>&lt; EqSpec, delaysSpec, MatrixSpec, VectorSpec &gt;::vectorToSolution </td>
          <td>(</td>
          <td class="paramtype">Vector const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>use <a class="el" href="classcapd_1_1ddeshelper_1_1NonrigorousHelper.html#a1de2b2ecf29aba01679877dd5f308f1e">makeSegment()</a> instead! </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/robson/ROBERT-PRACA-CHMURA/eclipse-workspace/capdDDEs5.1.2/include/capd/ddeshelper/<a class="el" href="DDEHelperNonrigorous_8h_source.html">DDEHelperNonrigorous.h</a></li>
<li>/home/robson/ROBERT-PRACA-CHMURA/eclipse-workspace/capdDDEs5.1.2/include/capd/ddeshelper/<a class="el" href="DDEHelperNonrigorous_8hpp_source.html">DDEHelperNonrigorous.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
